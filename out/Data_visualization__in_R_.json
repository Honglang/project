[{"blogurl": "http://rdataviz.wordpress.com\n", "blogroll": [], "title": "Data visualization (in R)"}, {"content": ["Following discussion on the comments of the previous post , I thought about how it was possible to draw links going in several directions (i.e. there are no \u2018clear\u2019 differences between the levels, and species from level n can interact with species of level n, n+1, n-1, n\u00b1k, etc). \n \n This is now done, with a code that is as inelegant as humanly possible. Also, the way to lay the different nodes on the graph (i.e. their \u2018trophic level\u2019) should be calculated with a proper method, but (i) I am not a specialist of these metrics, and (ii) it is way too late to do any decent bibliographical research to look them up. \n The procedure I use here is quite horrible. I randomly reorder the matrix, and compute the trophic position by elevating each species whenever it eats another species. I repeat this a couple time, and then average the trophic position for each species. The x position is a simple random value, which means that you will probably need to do the launch the code a couple times to get a decent looking network. \n The R code can be downloaded here ."], "link": "http://rdataviz.wordpress.com/2010/07/06/drawing-a-trophic-network-part-2/", "bloglinks": {}, "links": {"http://www.timotheepoisot.fr/": 1, "http://feeds.wordpress.com/": 7, "http://rdataviz.wordpress.com/": 1}, "blogtitle": "Data visualization (in R)"}, {"content": ["I published a short function to draw trophic networks with several levels, with links going from level n+1 to level n only. It will only be of interest for people working in ecology (but if you see another possible use, please let me know). \n It is available here \u2013 with examples. \n If I continue to publish at this rhythm, expect a brand new post around november!"], "link": "http://rdataviz.wordpress.com/2010/07/06/draw-a-trophic-network-with-n-levels/", "bloglinks": {}, "links": {"http://www.timotheepoisot.fr/": 1, "http://feeds.wordpress.com/": 7}, "blogtitle": "Data visualization (in R)"}, {"content": ["Hi there! \n This blog will be dedicated to data visualization in R. Why? Two reasons. First, when it comes to statistics, I am always starting by some exploratory analyses, mostly with plots. And when I handle large quantities of data, it\u2019s nice to make some graphs to get a grasp about what is going on. Second, I have been a teacher as part of my PhD, and I was quite appaled to see that even Masters students have very bad visualization practices. \n My goal with this blog is to share ideas/code with the R community, and more broadly, with anybody with an interest in data visualization. Updates will not be regular. This first post will be dedicated to the building of a plot digitizer in R, i.e. a small function to get the data from a plot in graphic format. \n I have recently been using programs such as GraphClick and PlotDigitizer to gather data from graphs, in order to include them in future analyses (in R). While both programs are truly excellent and highly intuitive (with a special mention to GraphClick), I found myself wondering if it was not possible to digitize a plot directly in R. \n And yes, we can. Let\u2019s think about the steps to digitize a plot. The first step is obviously to load the image in the background of the plot. The second is to set calibration points. The third step is boring as hell, as we need to click the points we cant to get the data from. Finally, we just need to transform the coordinates in values, with the help of very simple maths. And this is it! \n OK, let\u2019s get this started. We will try to get the data from this graph: \n \n Setting the plot \n First, we will be needign the ReadImages library, that we can install by typing : \n \ninstall.packages('ReadImages')\n \n This packages provides the read.jpeg function, that we will use to read a jpeg file containing our graph : \n \nmygraph <- read.jpeg('plot.jpg')\nplot(mygraph)\n \n I strongly recommend that before that step, you start by creating a new window ( dev.new() ), and expand it to full size, as it will be far easier to click the points later on. \n Calibration \n So far, so good. The next step is to calibrate the graphic, by adding four calibration points of known coordinates. Because it is not always easy to know both coordinates of a point, we will use four calibration points. For the first pair, we will know the x position, and for the second pair, the y position. That allows us to place the points directly on the axis. \n \ncalpoints <- locator(n=4,type='p',pch=4,col='blue',lwd=2)\n \n We can see the current value of the calibration points : \n \nas.data.frame(calpoints)\n   x  y\n1 139.66429 73.8975\n2 336.38388 73.8975\n3 58.72237 167.0254\n4 58.72237 328.1680\n \n Point\u2019n'click \n The third step is to click each point, individually, in order to get the data. \n \ndata <- locator(type='p',pch=1,col='red',lwd=1.2,cex=1.2)\n \n After clicking all the points, you should have the following graph : \n \n Our data are, so far : \n \nas.data.frame(data)\n   x   y\n1 104.8285 78.08303\n2 138.6397 114.70636\n3 171.4263 119.93826\n4 205.2375 266.43158\n5 238.0241 267.47796\n6 270.8107 275.84901\n7 302.5727 282.12729\n8 336.3839 298.86939\n9 370.1951 306.19405\n10 401.9571 352.23481\n \n OK, this is nearly what we want. What is left is just to write a function that will convert our data into the true coordinates. \n Conversion \n It seems straightforward that the relationship between the actual scale and the scale measured on the graphic is linear, so that \n \n and as such, both a and b can be simply obtained by a linear regression. \n We can write the very simple function calibrate : \n \ncalibrate = function(calpoints,data,x1,x2,y1,y2)\n{\n\tx <- calpoints$x[c(1,2)]\n\ty <- calpoints$y[c(3,4)]\n\tcx <- lm(formula = c(x1,x2) ~ c(x))$coeff\n\tcy <- lm(formula = c(y1,y2) ~ c(y))$coeff\n\tdata$x <- data$x*cx[2]+cx[1]\n\tdata$y <- data$y*cy[2]+cy[1]\n\treturn(as.data.frame(data))\n}\n \n And apply it to our data : \n \ntrue.data <- calibrate(calpoints,data,2,8,-1,1)\n \n Which give us : \n \n true.data\n   x   y\n1 1.010309 -2.0909091\n2 2.000000 -1.6363636\n3 3.051546 -1.5714286\n4 3.979381 0.2337662\n5 5.000000 0.2467532\n6 5.958763 0.3506494\n7 6.979381 0.4285714\n8 8.000000 0.6493506\n9 8.989691 0.7272727\n10 9.979381 1.3116883\n \n And we can plot the data : \n \nplot(true.data,type='b',pch=1,col='blue',lwd=1.1,bty='l')\n \n \n Not so bad! \n Conclusion \n With the simple use of R, we were able to construct a \u201cpoor man\u2019s data extraction system\u201d (PMDES, \u00a9), based on the incorporation of graphics in the plot zone, and the locator capacity of R. \n We can wrap-up everything in functions for better usability : \n \nlibrary(ReadImages)\n\nReadAndCal = function(fname)\n{\n\timg <- read.jpeg(fname)\n\tplot(img)\n\tcalpoints <- locator(n=4,type='p',pch=4,col='blue',lwd=2)\n\treturn(calpoints)\n}\n\nDigitData = function(color='red') locator(type='p',pch=1,col=color,lwd=1.2,cex=1.2)\n\nCalibrate = function(calpoints,data,x1,x2,y1,y2)\n{\n\tx <- calpoints$x[c(1,2)]\n\ty <- calpoints$y[c(3,4)]\n\tcx <- lm(formula = c(x1,x2) ~ c(x))$coeff\n\tcy <- lm(formula = c(y1,y2) ~ c(y))$coeff\n\tdata$x <- data$x*cx[2]+cx[1]\n\tdata$y <- data$y*cy[2]+cy[1]\n\n\treturn(as.data.frame(data))\n}\n \n Do you have any ideas to improve these functions? Let\u2019s discuss them in the comments!"], "link": "http://rdataviz.wordpress.com/2010/03/05/getting-data-from-an-image-introductory-post/", "bloglinks": {}, "links": {"http://feeds.wordpress.com/": 7, "http://plotdigitizer.sourceforge.net/": 1, "http://www.arizona-software.ch/": 1}, "blogtitle": "Data visualization (in R)"}]