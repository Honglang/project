[{"blogurl": "http://blogs.sas.com/content/iml\n", "blogroll": [], "title": "The DO Loop"}, {"content": ["The determinant of a matrix arises in many statistical computations, such as in estimating parameters that fit a distribution to multivariate data. For example, if you are using a log-likelihood function to fit a multivariate normal distribution, the formula for the log-likelihood involves the expression log(det(\u03a3)), where \u03a3 is the covariance matrix for the population. Similar formulas appear for log-likelihood estimation of spatial models.\n \nThe determinant of a matrix is a high-degree polynomial, so it can be huge for even moderate-sized matrices. For example, the determinant of a Vandermonde matrix with consecutive integer elements increases super-factorially with the dimension of the matrix! For a 30 x 30 integer Vandermonde matrix, the determinant is too large to represent as a standard double-precision floating-point number.\n \nBut here's an important point: in many statistical applications, you don't care about the determinant . All you need is the logarithm of the determinant. That is a much, much, smaller number!\n \nHere's a trick that you can use. To computing the logarithm of a determinant, do NOT try to compute the determinant itself. Instead, compute the log-determinant directly! For matrices with a large determinant, the computation of the log-determinant will usually succeed whereas the computation of the determinant might cause a numerical overflow error.\n \nHere's how you can compute the log-determinant in the important case of a positive definite matrix, such as for a covariance matrix.\n \nLet A be your matrix and let G = root(A) be the Cholesky root of the matrix A. Then the following equation is true: \n  log(det(A)) = 2*sum(log(vecdiag(G))) \n \nHere's a proof:\n \n A = G`*G, by definition of the Cholesky root\n log(det(A)) = log(det(G`*G)) = log(det(G`)*det(G)) = 2*log(det(G))\n Since G is triangular, det(G) = prod(vecdiag(G))\n Therefore log(det(G))=sum(log(vecdiag(G)))\n Consequently, log(det(A)) = 2*sum(log(vecdiag(G)))\n \n \nHere's how you can compute the log-determinant in the SAS/IML language:\n \n\n\n proc iml;\nstart logdet(A);\n G = root(A);\n return( 2*sum(log(vecdiag(G))) );\nfinish; \n\n\n\n\n Let's use this formula on a 50x50 symmetric positive definite matrix. The following statements create a symmetric matrix with random uniform variates on the off-diagonal and the value 50 along the diagonal. This matrix is diagonally dominant , and therefore positive definite:\n \n\n\n n = 50; \nr = j(n*(n+1)/2, 1);  /* allocate array for symmetric elements */\ncall randgen(r, \"uniform\"); /* fill r with U(0,1) */\nA = sqrvech(r);    /* A is symmetric */\ndiagIdx = do(1,n*n, n+1);\nA[diagIdx] = n;    /* set diagonal elements */ \n\n\n\n\n \nThe determinant of A is about 7.75 x 10 84 .\nTo test the log-determinant function, let's compute the log-determinant of A in three different ways: by calling the DET function, by computing eigenvalues, and by calling the logDet function:\n \n\n\n LogDet1 = log(det(A));   /* 1. DET function */\nLogDet2 = log(prod(eigval(A))); /* 2. product of eigenvalues */\nLogDet3 = logDet(A);   /* 3. direct computation of log(det(A)) */\n \nprint LogDet1 LogDet2 LogDet3; \n\n\n\n\n \n\n \nThe first two methods compute the determinant, and are therefore subject to overflow when the determinant is extremely large. The logDet function, however, does not ever compute the determinant. It computes the log-determinant directly.\n \nSweet! This TRICK is a real TREAT! tags: Matrix Computations , Numerical Analysis , Statistical Programming , Tips and Techniques"], "link": "http://feedproxy.google.com/~r/TheDoLoop/~3/W2mp75RpVSQ/", "bloglinks": {}, "links": {"http://mathworld.wolfram.com/": 2, "http://blogs.sas.com/": 4, "http://en.wikipedia.org/": 1, "http://www.berkeley.edu/": 1}, "blogtitle": "The DO Loop"}, {"content": ["I was looking at some SAS documentation when I saw a Base SAS function that I never knew existed. \nThe NWKDOM function returns the date for the n th occurrence of a weekday for the specified month and year.\nI surely could have used that function last spring when I blogged about how to compute the onset and end of daylight saving time (DST) in SAS !\n \n \nAs any handyman will tell you, having the right tool makes a job so much easier. Instead of nine complicated lines of SAS DATA step code, my new algorithm consists of two calls to the NWKDOM function! In the US, DST ends on the first Sunday in November. Here's all you need to do to figure out that date in 2012: nwkdom(1, 1, 11, 2012) . The first argument specifies the week (first=1). The second argument specifies the day of the week as a number 1\u20137 (Sunday=1). The third argument specifies the month as a number 1\u201312 (November=11). The last argument is the year.\n \n\n Therefore, the following DATA step code computes the beginning and end of DST for several years:\n \n\n\n /* compute the beginning and end of daylight saving time for several years */ \n data DST;\n format dst_beg dst_end DATE5.;\n do year = 2012 to 2022 ;\n dst_beg = nwkdom ( 2 , 1 , 3 , year ) ; /*DST begins 2nd Sun in March */ \n dst_end = nwkdom ( 1 , 1 , 11 , year ) ; /*DST ends 1st Sun in Nov */ \n output ;\n end ;\n run ;\n \n proc print noobs; \n var year dst_beg dst_end;\n run ; \n\n\n\n\n \n\n \nWith the right tools, every task is easier.\n tags: SAS Programming"], "link": "http://feedproxy.google.com/~r/TheDoLoop/~3/Yb6dF3FZ88Q/", "bloglinks": {}, "links": {"http://blogs.sas.com/": 2, "http://support.sas.com/": 1}, "blogtitle": "The DO Loop"}, {"content": ["There are a lot of useful probability distributions that are not featured in standard statistical textbooks. Some of them have distinctive names. In the past year I have had contact with SAS customers who use the Tweedie distribution , the slash distribution , and the PERT distribution . Often these distributions are used as part of a simulation study. \nThis article describes how to simulate from the PERT distribution in SAS.\n \nI had never heard of the PERT distribution prior to last week, but apparently it is related to the Project Evaluation and Review Technique (PERT) , which is \"a statistical technique for measuring and forecasting progress in research and development programs.\" Suppose management wants to know how long a project will take. This might be hard to estimate if the project consists of several interrelated tasks. However, perhaps you can estimate the length of each task and use those estimates to estimate the duration of the full project, hopefully with a statistical confidence interval.\n \nTo estimate the length of a task, you ask the manager (or some other expert) to tell you the minimum time it will take, the maximum time it will take, and the most likely time to complete the task. You might get an answer such as, \"It will take at least five weeks, but probably more like eight weeks. Even in the worst case scenario, it'll be done in 20 weeks.\"\n \nThe PERT distribution turns those three numbers into a probability distribution, as shown in the following image. The minimum value of the distribution is 5, the maximum value is 20, and the mode of the distribution (the location of the peak) is at 8.\n \n\n \n\n \nThe PERT distribution isn't really a new distribution; it is a translated and scaled version of the well known beta distribution . The beta distribution is defined on the interval [0,1], but a simple linear transformation scales and translates the distribution onto any interval [min, max]. The beta distribution has two parameters, \u03b1 and \u03b2, which determine the shape of the distribution. If I tell you that I want a beta distribution with a certain mean and a certain mode, you can find the values of \u03b1 and \u03b2 that satisfy my request.\nThe mode is one of the parameters that the expert provides. The PERT distribution specifies that the mean is a certain weighted sum of the minimum, maximum, and mode. \n \nConsequently, it is easy to simulate from the PERT distribution: \n \n Specify the parameters min , mode , and max . These are used to determine the mean of the distribution.\n Apply a linear transformation to determine the corresponding mode and mean for the beta distribution on [0,1]. Solve for the corresponding parameters, \u03b1 and \u03b2.\n Simulate data from the Beta(\u03b1, \u03b2) distribution. Translate and scale the data onto the interval [ min , max ]. \n \n \n \nThe following DATA step simulates 2,000 observations from a PERT distribution with min=5, mode=8, and max=20. The UNIVARIATE procedure is used to plot the resulting histogram and to overlay the underlying beta distribution:\n\n\n data PERT;\n keep y;\n call streaminit ( 123 ) ;\n N = 2000 ; \na = 5 ; /* min */ \nb = 8 ; /* mode */ \nc = 20 ; /* max */ \nmu = ( a + 4 *b + c ) / 6 ; /* mean as weighted sum of parameters */ \n /* find parameters for Beta distribution on [0,1] */ \nalpha = ( mu-a ) * ( 2 *b-a-c ) / ( ( b-mu ) * ( c-a ) ) ;\nbeta = alpha* ( c-mu ) / ( mu-a ) ;\n do i = 1 to N ;\n y = rand ( \"Beta\" , alpha, beta ) ; /* y in [0,1] */ \n y = a + ( c-a ) *y;    /* translate to [min, max] */ \n output ;\n end ;\n run ;\n \n /* display histogram and fit to translated and scaled Beta */ \n proc univariate data =PERT;\n histogram y / beta ( theta= 5 sigma= 15 alpha= 1.8 beta= 4.2 ) endpoints= ( 5 to 20 ) ;\n run ; \n\n\n\n \nThe graph (shown earlier in this article) shows the probability distribution of the duration of the task. Suppose that there are three sequential tasks, A, B, and C. Task A must be completed before B can begin, and Task B must be completed before C can begin. You can simulate the distribution of project duration times by simulating a time for each task and adding the three times together. Do this many times and you have an approximate distribution for the duration of the project.\n \nThe same process provides confidence intervals and probabilities for the duration of the project. For example, in the single-task case of the PERT distribution, you can estimate the probability that the task will take 12 weeks or longer:\n \n\n\n data Prob;\n set PERT;\n Delay = ( y> 12 ) ; /* indicator var: 1 if task takes more than 12 weeks */ \n run ;\n proc freq data =Prob;\n table Delay / nocum; /* what percent of times took more than 12 weeks? */ \n run ; \n\n\n\n\n \n\n \nFor this one task, the probability that it will take more than 12 weeks is 19%. In the case of a single task, you can use the QUANTILE function to compute probabilities from the beta distribution, but in general the project time is the sum of several beta random variables, each with different parameters, so you need to use the simulated sampling distribution to estimate the probability.\n \n \nI can see how techniques like this would be very useful for keeping track of big projects. Apparently this technique was used in the 1960's for estimating the length of projects in the US Navy and for projects leading up to the 1968 (Grenoble) Olympics. \n tags: Sampling and Simulation"], "link": "http://feedproxy.google.com/~r/TheDoLoop/~3/qSuuGqALC0M/", "bloglinks": {}, "links": {"http://blogs.sas.com/": 2, "http://en.wikipedia.org/": 4, "http://www.vosesoftware.com/": 1}, "blogtitle": "The DO Loop"}, {"content": ["What's in a name? As Shakespeare's Juliet said, \"That which we call a rose / By any other name would smell as sweet.\"\nA similar statement holds true for the names of colors in SAS:\n\"Rose\" by any other name would look as red!\n \n SAS enables you to specify a color in several ways . This article shows how to use color names and RGB colors to specify colors in the SAS statistical graphics procedures, such as PROC SGPLOT. It gathers together color resources in a single location, so you might want to bookmark this article for future reference.\n \n Pre-defined SAS color names \n \nSAS knows dozens of names of colors.\nThere's \"red\" and \"brown,\" of course, but also designer colors such as \"aquamarine,\" \"chartreuse,\" \"khaki,\" and \"teal.\" The following call to the SGPLOT procedure creates a scatter plot for which the marker color is set to \"rose\":\n \n\n\n proc sgplot data =sashelp.class;\nscatter x =height y=weight / markerattrs= ( size= 14 symbol=CircleFilled\n       color= \"Rose\" ) ;\n run ; \n\n\n\n\n \n\n \nIf you want to see some of the color names that SAS recognizes, run the following statements, which will print a list of colors to the SAS log:\n \n\n\n proc registry list startat= \"COLORNAMES\" ;\n run ; \n\n\n\n\n\n The SAS color-naming convention \n \n\nSome of the more \"imaginative\" names that SAS supports (such as \"Peru,\" \"Thistle,\" and \"Gainsboro\") might be unfamiliar. Fortunately,\n SAS has a color-naming scheme that enables you to specify a descriptive name for many colors, such as \"Red,\" \"Light Gray,\" or \"Dark Green.\"\nTo use the color-naming scheme, choose one value from each of the following categories:\n \n Lightness: Black (*), Very Dark, Dark, Medium (default), Light, Very Light, or White (*)\n Saturation: Gray (*), Grayish, Moderate, Strong, Vivid (default)\n Hue: Blue, Purple, Red, Orange or Brown, Yellow, Green\n \n\n \nSo, for example, valid names for colors include the following:\n \n \"Very Dark Grayish Blue\"\n \"Dark Moderate Purple\"\n \"Strong Red\" (default value for Lightness)\n \"Light Brown\" (default value for Saturation)\n \n \nA few exceptions to the \"choose one from each category\" rule are indicated by asterisks. If you use Black or White, you cannot specify Saturation or Hue. Similarly, if you specify Gray, you cannot specify a Hue.\n \nYou can also specify a mixture of hues by specifying two adjacent hues in the list. Optionally, you can use the -ish suffix to diminish a hue, as in the following examples:\n \n \n \"Medium Strong Red Orange\"\n \"Light Yellowish Green\" \n \"Light Strong Brownish Orange\" \n \n \nFor example, the following scatter plot sets the color of markers by using the SAS color-naming scheme:\n \n\n\n proc sgplot data =sashelp.class;\nscatter x =height y=weight / markerattrs= ( size= 14 symbol=CircleFilled\n       color= \"Light Strong Brownish Orange\" ) ;\n run ; \n\n\n\n\n \n\n\n Representing colors by their RGB values \n \n\nSAS also enables you to specify a color by using the red-green-blue (RGB) color model . \nThe RGB color model is an additive model in which a color is specified in terms of red, green, and blue components. Each component ranges from 0 (which indicates the absence of a component) to 255 (which indicates the full presence of a component). A color is therefore a triplet of values that indicates the relative proportions of red, green, and blue. For example, the RGB triplet (255, 96, 96) represents a color that has a maximum amount of red and a small amount of green and blue. \n \nThe drawback of the RGB model is readability. If I write a program and specify a color as the RGB triplet (255, 96, 96), it is difficult to know what color is going to be produced. \nIt turns out that this color is exactly \"Rose,\" but you might have had a hard time predicting that in advance. \n \nMost of the time, RGB triplets are compactly represented by a hexadecimal integer. The prefix CX tells SAS to interpret the integer as a color. You can find the hexadecimal representation of a color such as \"Rose\" by using the handy reference chart that lists SAS colors and their hexadecimal values . \n \n\nThe chart says that the RGB color for \"Rose\" is CXFF6060. This value is read two digits at a time: \n \n \n CX means that the value is a color\n FF is the hexadecimal (base-16) value for 16*15 + 15 = 255, which is the red component\n 60 is the hexadecimal value for 16*6 + 0 = 96, which is the green component\n 60 is the blue component\n \n \n\nConsequently, the following statements reproduce the first image in this article:\n \n\n\n /* \"Rose\" = RGB(255,96,96) = cxFF6060 */ \n proc sgplot data =sashelp.class;\nscatter x =height y=weight / markerattrs= ( size= 14 symbol=CircleFilled\n       color=cxFF6060 ) ;\n run ; \n\n\n\n\n \nIf you are a hard-core programmer, you're probably already thinking about how to write a SAS macro that converts a triplet of RGB values into a hexadecimal color. If you want to try to construct the macro yourself, stop reading now!\n \n \nYou can use the following SAS macro to create a hexadecimal value from a triplet of RGB colors. It's easy to use the PUT function to construct the hexadecimal value inside of a DATA step, but it is slightly more challenging to use the macro language to construct an \"in-line\" string that can be used outside of the DATA step. You can use the following macro to specify the COLOR= option for statement in the SGPLOT procedure:\n \n\n\n /* convert integer 0--255 to 2 digit hex 00-FF */ \n %macro hex2 ( n ) ;\n %local digits n1 n2;\n %let digits = 0123456789ABCDEF;\n %let n1 = %substr ( &digits , &n / 16 + 1 , 1 ) ;\n %let n2 = %substr ( &digits , &n - &n / 16 * 16 + 1 , 1 ) ;\n &n1 &n2 \n %mend hex2;\n \n /* convert RGB triplet (r,g,b) to SAS color in hexadecimal. \n The r, g, and b parameters are integers in the range 0--255 */ \n %macro RGB ( r,g,b ) ;\n %cmpres ( CX%hex2 ( &r ) %hex2 ( &g ) %hex2 ( &b ) ) \n %mend RGB;\n \n data A;\n put \"Rose = %RGB(255,96,96)\" ;\n run ;\n \n proc sgplot data =sashelp.class;\nscatter x =height y=weight / markerattrs= ( size= 14 symbol=CircleFilled\n       color=%RGB ( 255 , 96 , 96 ) ) ;\n run ; \n\n\n\n \nBecause (255, 96, 96) specifies the same color as \"rose,\" the image is identical to the first graph in this article.\n \nSo what's in a name? A lot of information! But in SAS, \"rose\" by the name of CXFF6060 looks just as sweet!\n tags: Getting Started , SAS Programming , Statistical Graphics"], "link": "http://feedproxy.google.com/~r/TheDoLoop/~3/NE_nVOyD-L4/", "bloglinks": {}, "links": {"http://blogs.sas.com/": 5, "http://support.sas.com/": 4}, "blogtitle": "The DO Loop"}, {"content": ["Sometimes a graph is more interpretable if you assign specific colors to categories. For example, if you are graphing the number of Olympic medals won by various countries at the 2012 London Olympics, you might want to assign the colors gold, silver, and bronze to represent first-, second-, and third-place medals. A good choice of colors can reduce the time that a reader spends studying the legend, and increase the time spent studying the data.\nIn this example, I assign a \"traffic light\" scheme to visualize data about gains and losses: \ngreen means positive gains, gray indicates little or no change, and red indicates negative change. \n \nThe SGPLOT procedure in SAS makes it easy to display a different color for each level of a grouping variable. By default, when you specify the GROUP= option for a graph, colors are assigned to groups based on the current ODS style . But what can you do if you want to assign specific colors for group categories?\n \n \nThere are several ways to assign colors to categories, including using PROC TEMPLATE to write your own ODS style. However, in SAS 9.3, the easiest option is to use an \"attribute map.\" \nAn attribute map is a small data set that describes how each category level should be rendered. Dan Heath wrote a blog post about the attribute map. In this article I give a simple example of using an attribute map with the SGPLOT procedure, and I show that you can use a format to help you create an attribute map.\n \nIn my last article, I created a scatter plot that shows the gains made by women in the workplace . This graph is reproduced below, and you can \n download the SAS program that contains the data and that creates the plot . The colors make it clear that the proportion of women has increased in most job categories. \n\n\n \n\n\n \n\nThe program begins by using PROC format to define a mapping between a continuous variable (the difference between the proportion of women in 1980 and the proportion in 2010) and five discrete levels:\n\n\n proc format ;\nvalue Gain low-< - 10 = \"Large Loss\" /* [low,-10) */ \n   - 10 -< - 5 = \"Loss\"   /* [-10, -5) */ \n   - 5 -  5 = \"No Change\" /* [ -5, 5] */ \n    5 - 10 = \"Gains\"  /* ( 5, 10] */ \n    10 - high= \"Large Gains\" ; /*( 10, high] */ \n run ; \n\n\n\n \nNotice that because I use a format, there is not an explicit categorical variable in the data set. Instead, there is a continuous variable (the difference) and a format on that variable.\n \n\nNevertheless, you can assign a color to each category by creating an attribute map that assigns formatted values to colors. To do this, define two variables, one named Value and the other MarkerColor . The values of the Value variable define the categories; the corresponding values of the MarkerColor variable define the colors of markers in the scatter plot. (There are other columns that you could define, such as LineColor and MarkerSymbol .)\nYou could hard-code the values \"Large Loss,\" \"Loss\", and so forth, but why not use the fact that there is a format? That way, if the labels in the format change, the graph will pick up the new labels. The following DATA step uses the PUTN function to apply the user-defined format to values that are representative of each category:\n \n\n\n data Attrs;\n length Value $20 MarkerColor $20;\nID = \"Jobs\" ; \nValue = putn ( - 15 , \"Gain.\" ) ; MarkerColor = \"DarkRed  \" ; output ;\nValue = putn ( - 8 , \"Gain.\" ) ; MarkerColor = \"DarkOrange \" ; output ;\nValue = putn ( 0 , \"Gain.\" ) ; MarkerColor = \"MediumGray \" ; output ;\nValue = putn ( 8 , \"Gain.\" ) ; MarkerColor = \"GrayishGreen\" ; output ;\nValue = putn ( 15 , \"Gain.\" ) ; MarkerColor = \"DarkGreen \" ; output ;\n run ; \n\n\n\n \nNotice also that the attribute map includes an ID variable that is used to identify the map, because you can define multiple attribute maps in a single data set. \n \nEquivalently, you could use arrays to store the \"cut points\" for each category, and use a loop to iterate over all possible categories. This is more general, and I think that the cut points make the program easier to understand than the \"strange\" numbers (15 and 8) in the previous attribute map.\n \n\n\n data Attrs2;\n length Value $20 MarkerColor $20;\nID = \"Jobs\" ;    \n array cutpts { 6 } _temporary_ ( - 100 - 10 - 5 5 10 100 ) ;\n array colors { 5 } $20 _temporary_ \n  ( \"DarkRed\" \"DarkOrange\" \"MediumGray\" \"GrayishGreen\" \"DarkGreen\" ) ;\n drop i v;\n do i = 1 to dim ( cutpts ) - 1 ;\n v = ( cutpts [ i+ 1 ] + cutpts [ i ] ) / 2 ; /* midpoint of interval */ \n Value = putn ( v, \"Gain.\" ) ;   /* formatted value for this interval */ \n MarkerColor = colors [ i ] ;   /* color for this interval */ \n output ;\n end ;\n run ; \n\n\n\n \nTo use an attribute map, you have to specify two pieces of information: the data set ( Attrs ) and the ID variable ( Jobs ). You specify the data set by using the DATTRMAP= option on the PROC SGPLOT statement. You specify the map by using the ATTRID= option on the SCATTER statement, as follows:\n \n\n\n proc sgplot data =Jobs DATTRMAP=Attrs; \nscatter x =PctFemale1980 y=PctFemale2010 / group =Diff ATTRID=Jobs; \n run ; \n\n\n\n\n \nAttribute maps are a useful feature of the SG procedures in SAS 9.3.\nMost of the time, the default colors that are defined in ODS styles are sufficient for visualizing grouped data. However, you can use attribute maps when you need to assign specific colors to categories. \nAs I've shown in this article, you can also assign a color to a category that is defined by a format. In either case, an attribute map can make it easier for your audience to understand the data. tags: Data Analysis , SAS Programming , Statistical Graphics"], "link": "http://feedproxy.google.com/~r/TheDoLoop/~3/JPa52w6t3dM/", "bloglinks": {}, "links": {"http://blogs.sas.com/": 7, "http://support.sas.com/": 1}, "blogtitle": "The DO Loop"}, {"content": ["The New York Times has an excellent staff that produces visually interesting graphics for the general public . However, because their graphs need to be understood by all Times readers, the staff sometimes creates a complicated infographic when a simpler statistical graph would show the data in a clearer manner.\n \nA recent graphic was discussed by Kaiser Fung in his article, \n \"When Simple Is too Simple.\" Kaiser argued that the Times made a poor choice of colors in a graphic (shown at right) that depicts the proportion of women in certain jobs and how \nthat proportion has changed between 1980 and 2010. \n \n\nI agree with Kaiser that the colors should change, and I will discuss colors in a subsequent blog post. However, I think that the graph itself suffers from some design problems. First, it is difficult to see overall trends and relationships in the data. Second, in order to understand the points on the left side of the graph, you have to follow a line to the right side of the graph in order to find the label. Third, the graph is too tall. At a scale in which you can read the labels, only half the graph appears on my computer monitor. If printed on a standard piece of paper, the labels would be quite small.\n \n \nYou can overcome these problems by redesigning the graph as a scatter plot. I presume that the Times staff rejected the scatter plot design because they felt it would not be easily interpretable by a general Times reader. Another problem, as we will see, is that a scatter plot requires shorter labels that the ones that are used in the Times graphic. \n \nA scatter plot of the same data is shown in the next figure. (Click to enlarge.)\nThe graph shows the proportion of women in 35 job categories. The horizontal axis shows the proportion in 1980 and the vertical axis shows the proportion in 2010. Jobs \nsuch as secretary, hygienist, nurse, and housekeeper\nare primarily held by women (both in 1980 and today) and appear in the upper right.\nJobs such as auto mechanic, electrician, pilot, and welder are primarily held by men (both in 1980 and today) and appear in the lower left. Jobs shown in the middle of the graph (bus driver, reporter, and real estate agents) are held equally by men and women.\n \nThe diagonal line shows the 1980 baseline. Points that are displayed above that line are jobs for which the proportion of women has increased between 1980 and 2010. This graph clearly shows that the proportion of women in most jobs has increased or stayed the same since 1980. (I classify a deviation of a few percentage points as \"staying the same,\" because this is the margin of error for most surveys.) Only the job of \"welfare aide worker\" has seen a substantial decline in the proportion of women.\n \n \n\n\n\n \nThe markers are colored on a red-green scale according to the gains made by women. Large gains (more than 10%) are colored a dark green. Lesser gains (between 5% and 10% are a lighter green. Similarly, jobs for which the proportion of women declined are shown in red. Small changes are colored gray.\n \nThis graph shows the trend more clearly than the Times graphic. You can see at a glance that women have made strides in workplace equity across many fields. In many high-paying jobs such as doctor, lawyer, dentist, and various managerial positions, women have made double-digit gains.\n \nThe shortcomings of the graph include using shorter labels for the job categories, and losing some of the ability to know the exact percentages in each category. For example, what is the proportion of females that work as a welfare aide in 2010? Is it 68%, 67%, or 66%? This static graph does not give the answer, although if the graph is intended for an online display you can create tooltips for each point .\n \nFor those readers who are interested in the details, you can \n download the SAS program that creates this plot . The program uses three noteworthy techniques:\n \n A user-defined SAS format is used to display the differences in proportions into a categorical variable with levels \"Large Gains,\" \"Gains,\" \"No Change,\" and so on.\n \n An attribute map is used to map each category to a specified shade of red, gray, and green. This feature was introduced in SAS 9.3. My next blog post will discuss this step in more detail.\n \n The DATALABEL= option is used to specify a variable that should be used to label each point. The labels are arranged automatically. The SAS research and development staff spent a lot of time researching algorithms for the automatic placement of labels, and for this example the default algorithm does an excellent job of placing each label near its marker while avoiding overlap between labels.\n \n \n\n \nWhat do you think? Which graphic would you prefer to use to examine the gains made by women in the workplace? Do you think that the New York Times readers are sophisticated enough to read a scatter plot, or should scatter plots be reserved for scientific communication?\n \n\n tags: Data Analysis , Statistical Graphics"], "link": "http://feedproxy.google.com/~r/TheDoLoop/~3/eXCr0Q9Ix4s/", "bloglinks": {}, "links": {"http://junkcharts.typepad.com/": 1, "http://www.nytimes.com/": 1, "https://www.nytsyn.com/": 1, "http://blogs.sas.com/": 5}, "blogtitle": "The DO Loop"}, {"content": ["Last week I wrote a SAS/IML program that computes the odds of winning the game of craps . I noted that the program remains valid even if the dice are not fair. For convenience, here is a SAS/IML function that computes the probability of winning at craps, given the probability vector for each of the two six-sided dice. The program is explained in the previous article.\n \n\n\n proc iml;\nstart CrapsWin(dieProb);\n probs = dieProb` * dieProb; /* joint prob = product of marginals */\n events = repeat(1:6, 6) + T(1:6);\n P = j(1, 12, 0);   /* probability of each event */\n do i = 2 to ncol(P);  /* P(sum=2), ..., P(sum=12) */\n  idx = loc( events=i );\n  P[i] = sum( probs[idx] );\n end;\n point = (4:6) || (8:10);\n /*  Pr(7 or 11) + Prob(Making Point) */\n Pwin = P[7] + P[11] + sum(P[point]##2 / (P[point] + P[7]));\n return( Pwin );\nfinish; \n\n\n\n\n \nI got interested in this problem when I stumbled upon a Web page by Jung-Chao Wang for a course at Western Michigan University. Wang discusses the probability of winning at craps when the game is played with unfair dice. In particular, the Web page shows how the probabilities of winning at craps change if the dice are \"shaved.\" A \"shaved die\" is one that is not perfectly cubical, so that the faces with less area have a smaller probability of appearing than the faces with larger areas. \nFor example, you can increase the probability of rolling a 1 or 6 by sanding or trimming those two faces. The area of the 1 and 6 faces do not change, but the other four faces now have less area. Of course, you could also shave the non-1 and non-6 faces, which has the opposite effect. Wang calls this \"negative shaving.\" (By \"you,\" I really mean \"an unscrupulous cheat.\" This discussion is purely a theoretical exercise in probability; I do not advocate cheating.)\n \nFor each pairs of faces (such as 1-6) you can consider the odds of winning at craps when you play with two identical dice that have been negatively or positively shaved. What is interesting to me is that the effect of shaving depends (strongly) on the faces that you shave. If you shave the 1-6 face, you get a dramatically different behavior than if you shave the 2-5 or 3-4 faces. \n \n\n \n \nThe results are shown in the preceding graph (click to enlarge). If you shave the 1 and 6 faces, you dramatically decrease the probability of the shooter winning. If you shave the 3 and 4 faces, you increase the probability, but the effect is not as dramatic. Presumably \"the house\" would want to shave the 1 and 6 sides, whereas a crooked shooter would want to try to replace the house dice with dice that are shaved on the 3 and 4 faces. However, to increase the probability of the shooter winning by, say, 5%, the 3-4 faces would need to be shaved by a lot. In contrast, to decrease the probability of the shooter winning by 5%, much less tampering is required of the 1-6 faces. Thus the \"house\" that cheats is less likely to be detected than the shooter that cheats!\n \nHere's the program that creates the graph:\n \n\n\n /* change probability of landing on 1-6, 2-5, or 3-4 sides */\n/* Idea from J. C. Wang:\n http://www.stat.wmich.edu/wang/667/egs/craps2.html */\nshaved = T( do( -1/12, 1/6, 0.01 ) );\nWinProb = j(nrow(shaved), 3); /* results: winning probability */\ndo side = 1 to 3;\n do i = 1 to nrow(shaved);\n  dieProb = j(1, 6, 1/6 - shaved[i] );\n  dieProb[side||7-side] = 1/6 + 2*shaved[i];\n  WinProb[i, side] = CrapsWin(dieProb);\n end;\nend;\n \n/* graph the data with PROC SGPLOT */\nA = shaved || WinProb;\ncreate Craps from A[c={\"Shaved\" \"Side1\" \"Side2\" \"Side3\"}];\nappend from A; close Craps;\nquit;\n \nproc sgplot data=Craps;\ntitle \"Probability of Winning at Craps with Unfair Dice\";\nseries x=Shaved y=Side1 / curvelabel=\"Sides 1 & 6\";\nseries x=Shaved y=Side2 / curvelabel=\"Sides 2 & 5\";\nseries x=Shaved y=Side3 / curvelabel=\"Sides 3 & 4\";\nyaxis grid values=(0.35 to 0.7 by 0.05) label=\"Probability of Winning\";\nxaxis grid label=\"Change in Probability\";\nrun; \n\n\n\n\n \nI really like this graph because it reveals how important various pairs of faces are to making a point. \n \nFor example, a pair of dice that rolls many 1s and 6s are bad for the shooter, because the most common sums will be 2, 7, and 12. You lose if 2 or 12 appear on the first roll, although you win with a 7. However, if you happen to establish a point, you are in trouble. Rolling a 2 or 12 doesn't help you make your point, so the most likely scenario is that you will roll a 7 and lose.\n \nIn contrast, a pair of dice that rolls many 3s and 4s is good for the shooter. The most common sums will be 6, 7, and 8. You win with a 7. If you establish a point, it is likely to be a 6 or 8, which are the easiest points to make.\n \n \nThe ideas discussed in this article also apply to other kinds of \"crooked dice.\" \nThe SAS/IML program opens up a variety of scenarios to simulate. For example, if only one face appears more than the others, which face would the shooter want it to be? Which face would the house want it to be?\nYou could also modify the SAS/IML function to take two probability vectors, one for each die. Have fun simulating these scenarios, but remember: no cheating in real life!\n \n\n tags: Just for Fun , Statistical Programming"], "link": "http://feedproxy.google.com/~r/TheDoLoop/~3/Dv9vxMM6V-o/", "bloglinks": {}, "links": {"http://homepage.ntlworld.com/": 1, "http://www.wmich.edu/": 1, "http://blogs.sas.com/": 4}, "blogtitle": "The DO Loop"}, {"content": ["It is easy to simulate data that is uniformly distributed in the unit cube for any dimension. However, it is less obvious how to generate data in the unit simplex.\n \nThe simplex is the set of points (x 1 ,x 2 ,...,x d ) such that \u03a3 i x i = 1 and 0 \u2264 x i \u2264 1 for i = 1,2,..., d . Because the elements sum to 1, a uniform distribution on the unit simplex can be used for many statistical tasks, such as drawing a probability vector with d elements.\n \nThe simplest algorithm I know is Algorithm 3.23 in Kroese, Taimre, and Botev, (2011, p. 73), Handbook of Monte Carlo Methods , which generates N points from the exponential distribution and uses the fact that the interval between consecutive points in an exponential distribution are uniformly distributed. You can implement this algorithm by using the SAS DATA step or by using the following SAS/IML function:\n \n\n\n proc iml;\n/* generate points in standard simplex by using \n Algorithm 3.23 in Kroese, Taimre, and Botev, (2011, p. 73) */\nstart RandUniSimplex(N, d);\n x = j(N, d);     /* allocate matrix */\n call randgen(x, \"Exponential\"); /* fill with x ~ Exp */\n return( x / x[,+] );   /* set row sums to 1 */\nfinish; \n\n\n\n \nRecall that the expression x[,+] is a subscript reduction operator that returns the sum of the elements in each row of x .\n \nTo test the function, simulate 1,000 observations from the uniform distribution on the unit simplex in three dimensions. The data should be uniformly distributed on a planar triangle with vertices (1,0,0), (0,1,0) and (0,0,1).\nTo visualize the simulated data, you can write the data in the matrix to a SAS data set and use the SGPLOT procedure to display a scatter plot of the first two coordinates:\n \n\n\n call randseed(1);\nx = RandUniSimplex(1000, 3); /* generate obs in 3D simplex */\n \ncreate Simplex from x[c=(\"x1\":\"x3\")];\nappend from x; \nclose Simplex;\n \nproc sgplot data=Simplex;\n title \"Uniform Distribution in the Unit Simplex\";\n scatter x=x1 y=x2;\nrun; \n\n\n\n\n \n\n \nThe graph shows that first two variables are uniformly distributed in the two-dimensional unit simplex. The third coordinate is not shown because it is trivially derived from the first two: x 3 = 1 \u2013 x 1 \u2013 x 2 . \n tags: Getting Started , Sampling and Simulation"], "link": "http://feedproxy.google.com/~r/TheDoLoop/~3/uMqZEG4wBbs/", "bloglinks": {}, "links": {"http://www.edu.au/": 1, "http://blogs.sas.com/": 5}, "blogtitle": "The DO Loop"}, {"content": ["Gambling games that use dice, such as the game of \"craps,\" are often used to demonstrate the laws of probability. For two dice, the possible rolls and probability of each roll are usually represented by a matrix. Consequently, the SAS/IML language makes it easy to compute the probabilities of various events.\n \nFor two fair dice, the probability of any side appearing is 1/6. Because the rolls are independent, the joint probability is computed as the product of the marginal probabilities. You can also create a matrix that summarizes the various ways that each particular number can occur:\n \n\n\n proc iml;\ndieProb = j(1, 6, 1/6); /* each die is fair: Prob(any face)=1/6 */\n/* joint prob is indep = product of marginals */\nprobs = dieProb` * dieProb; /* 6x6 matrix; all elements = 1/36 */\nevents = repeat(1:6, 6) + T(1:6);\nprint events[c=(\"1\":\"6\") r=(\"1\":\"6\")]; \n\n\n\n\n \n \nYou can use the event and probs matrices to compute the probabilities of each possible sum of two dice. There are several ways to do this, but I like to use the LOC function to find the elements of the event matrix that correspond to each roll, and then add the associated probabilities:\n \n\n\n P = j(1, 12, 0); /* probability of each event */\ndo i = 2 to ncol(P);\n idx = loc( events=i );\n P[i] = sum( probs[idx] );\nend;\nprint P[format=6.4 c=(\"P1\":\"P12\")]; \n\n\n\n \n\n \nThe preceding table shows the probabilities of each roll. (Note that the probability of rolling a 1 with 2 dice is zero; the P[1] element is not used for any computations.) You can use the table to compute the probability of winning at craps . If you roll a 7 or 11 on the first roll, you win. If you roll a 2, 3, or 12, you lose. If you roll a 4, 5, 6, 8, 9, or 10 on the first roll (called \"the point\"), you continue rolling. You win if you can successfully re-roll your \"point\" before you roll a 7. It is an exercise in conditional probability that you can compute the probability of making a \"point\" in craps by summing a ratio of probabilities, as follows:\n\n \n\n\n win = {7 11};\nlose = {2 3 12};\npoint = (4:6) || (8:10);\n \nPwin1 = sum( P[win] ); /* Prob of winning on first roll */\nPLose1 = sum( P[lose] ); /* Prob of losing on first roll */\n/* Prob winning = Pr(7 or 11) + Prob(Making Point) */\nPwin = P[7] + P[11] + sum(P[point]##2 / (P[point] + P[7]));\nprint Pwin1 PLose1 Pwin; \n\n\n\n\n \n\n \nAccording to the computation, the probability of winning at craps is almost\u2014but not quite!\u201450%. \n \nThis exercise shows that having a matrix and vector language is useful for computing with probabilities. More importantly, however, this post sets the foundations for looking at the interesting case where the two dice are not fair. If you change the definition of dieProb (on the first line of the program) so that it is no longer a constant vector, all of the computations are still valid !\n \nNext week I will post an article that shows how the odds change if some sides of the dice are more likely to appear than others. Feel free to conduct your own investigation of unfair dice before then.\n tags: Just for Fun , Statistical Programming"], "link": "http://feedproxy.google.com/~r/TheDoLoop/~3/VSWOw4FHw8I/", "bloglinks": {}, "links": {"http://mathworld.wolfram.com/": 1, "http://en.wikipedia.org/": 2, "http://blogs.sas.com/": 3}, "blogtitle": "The DO Loop"}, {"content": ["John D. Cook posted a story about Hardy, Ramanujan, and Euler and discusses a conjecture in number theory from 1937. Cook says, \n \n\n Euler discovered 635,318,657 = 158^4 + 59^4 = 134^4 + 133^4 and that this was the smallest [integer] known to be the sum of two fourth powers in two ways. It seems odd now to think of such questions being unresolved. Today we\u2019d ask Hardy \u201cWhat do you mean 635318657 is the smallest known example? Why didn\u2019t you write a little program to find out whether it really is the smallest?\u201d\n \n \n \nCook goes on to encourage his readers to write a program that settles the conjecture, which is obviously no longer an open problem. Here's a SAS/IML solution. First, introduce a function that I use a lot:\n \n\n\n proc iml;\nstart ExpandGrid( x, y ); \n/* Return ordered pairs on a uniform grid of points */\n Nx = nrow(x); Ny = nrow(y);\n x = repeat(x, Ny);\n y = shape( repeat(y, 1, Nx), 0, 1 );\n return ( x || y );\nfinish; \n\n\n\n\n The ExpandGrid function generates a uniform grid of all ordered pairs of it's arguments. To solve the \"conjecture,\" generate all ordered pairs that contain the integers 1\u2013158 and check to see if the sum of fourth powers contain duplicate values. The number 158 is the greatest integer that is less than the fourth root of 635,318,657.\n \n\n\n /* settle conjecture of Euler/Hardy: Is 635,318,657 the smallest\n integer that can be written as the sum of 4th powers in two ways? */\nk = floor(635318657##0.25);  /* only need to test up to 4th root */\ng = ExpandGrid(t(1:k), t(1:k)); /* all ordered pairs */\ng = g[ loc(g[,1] <= g[,2]), ];  /* omit symmetric pairs */\nf = g[,1]##4 + g[,2]##4;   /* sum of 4th powers */\nprint (nrow(f)) (ncol(unique(f))); /* exactly one sum is the same */ \n\n\n\n\n \n\n\n\n \nThe output proves the conjecture: there are 12,561 ordered pairs of integers to consider, and there are 12,560 unique sums of fourth powers. That means that there is exactly one sum of fourth powers that can be written in two different ways, and Euler has already told us the particular values.\n \n \nIf you didn't know Euler's results, you could use the same computation to find Euler's values: sort the numbers by the sum of fourth powers and use the DIF function to take differences between consecutive elements. Print out the rows for which the difference is zero (that is, that the sum of fourth powers are equal):\n \n\n\n /* find the actual pairs of integers that have the same sum */\ng = g || f;     /* concatenate fourth powers onto pairs */\ncall sort(g, 3);    /* sort by sum of 4th powers */\nidx = loc(dif(g[,3])=0);  /* dif=0 <==> consecutive values equal */\nprint (g[idx-1:idx, ])[c={N1 N2 \"Sum\"}]; \n\n\n\n\n \n\n \nIt is fun to think of what someone like Euler might have accomplished if had the tools that we do today!\n tags: Just for Fun , Numerical Analysis"], "link": "http://feedproxy.google.com/~r/TheDoLoop/~3/8JBaVca8NCc/", "bloglinks": {}, "links": {"http://blogs.sas.com/": 2, "http://www.johndcook.com/blog": 1, "http://support.sas.com/": 1}, "blogtitle": "The DO Loop"}]