[{"blogurl": "http://learnr.wordpress.com\n", "blogroll": [], "title": "Learning R"}, {"content": ["Excel Charts Blog posted a video tutorial of how to create a circumplex or rose or dougnut chart in Excel. Apparently this type of chart is very popular in the consulting industry, hence the \u201cConsultants\u2019 Chart\u201d. \n  \n It is very easy to make this chart in Excel 2010, but it involves countless number of clicks and formulas to format both the source data and the chart itself. \n In ggplot2 the same can be achieved with around 10 lines of code, as can be seen below. \n  \n \n Set up dummy dataframe \n \n \n \n > set.seed(9876)\n> DF <- data.frame(variable = 1:10, value = sample(10,\n+  replace = TRUE))\n> DF\n variable value\n1   1  9\n2   2  4\n3   3  2\n4   4  6\n5   5  5\n6   6  3\n7   7  5\n8   8  7\n9   9  6\n10  10  2 \n \n \n \n \n Prepare the charts \n \n \n \n > library(ggplot2) \n \n \n \n Dougnut chart is essentially a bar chart using a polar coordinate system, so we start off with a simple bar chart. And to make life a bit more colourful will fill each slice with a different colour. \n \n \n \n > ggplot(DF, aes(factor(variable), value, fill = factor(variable))) +\n+  geom_bar(width = 1) \n \n \n \n  \n Next the coordinate system is changed and some of the plot elements are removed for a cleaner look. \n \n \n \n > last_plot() + scale_y_continuous(breaks = 0:10) +\n+  coord_polar() + labs(x = \"\", y = \"\") + opts(legend.position = \"none\",\n+  axis.text.x = theme_blank(), axis.text.y = theme_blank(),\n+  axis.ticks = theme_blank()) \n \n \n \n  \n \n Adding gridlines \n Update 17 August 2010 \n Several commentators asked how to draw gridlines on top of the slices as in the original example. \n Putting the gridlines/guides on top of the plot is accomplished by adding a new variable that is purely used for drawing the borders of each slice element. Essentially, it stacks the required number of slices with a white border on top of each other. \n \n \n \n > DF <- ddply(DF, .(variable), transform, border = rep(1,\n+  value))\n> head(DF, 10)\n variable value border\n1   1  9  1\n2   1  9  1\n3   1  9  1\n4   1  9  1\n5   1  9  1\n6   1  9  1\n7   1  9  1\n8   1  9  1\n9   1  9  1\n10  2  4  1 \n \n \n \n \n \n \n > ggplot(DF, aes(factor(variable))) + geom_bar(width = 1,\n+  aes(y = value, fill = factor(variable))) +\n+  geom_bar(aes(y = border, width = 1), position = \"stack\",\n+   stat = \"identity\", fill = NA, colour = \"white\") +\n+  scale_y_continuous(breaks = 0:10) + coord_polar() +\n+  labs(x = \"\", y = \"\") + opts(legend.position = \"none\",\n+  axis.text.x = theme_blank(), axis.text.y = theme_blank(),\n+  axis.ticks = theme_blank())"], "link": "http://learnr.wordpress.com/2010/08/16/consultants-chart-in-ggplot2/", "bloglinks": {}, "links": {"http://www.excelcharts.com/blog": 1, "http://had.co.nz/": 1, "http://feeds.wordpress.com/": 1}, "blogtitle": "Learning R"}, {"content": ["Waterfall charts are often used for analytical purposes in the business setting to show the effect of sequentially introduced negative and/or positive values. Sometimes waterfall charts are also referred to as cascade charts. \n In the next few paragraphs I will show how to plot a waterfall chart using ggplot2 . \n \n \n Data \n A very small fictional dataset depicting the changes to a company cash position, found in a blogpost showing how to prepare a waterfall chart in Tableau. \n \n \n \n \n > balance <- data.frame(desc = c(\"Starting Cash\",\n+  \"Sales\", \"Refunds\", \"Payouts\", \"Court Losses\",\n+  \"Court Wins\", \"Contracts\", \"End Cash\"), amount = c(2000,\n+  3400, -1100, -100, -6600, 3800, 1400, 2800))\n> balance\n   desc amount\n1 Starting Cash 2000\n2   Sales 3400\n3  Refunds -1100\n4  Payouts -100\n5 Court Losses -6600\n6 Court Wins 3800\n7  Contracts 1400\n8  End Cash 2800 \n \n \n \n \n In order to preserve the order of the lines in a dataframe I convert the desc variable to a factor; id and type variable are also added: \n \n \n \n \n > balance$desc <- factor(balance$desc, levels = balance$desc)\n> balance$id <- seq_along(balance$amount)\n> balance$type <- ifelse(balance$amount > 0, \"in\",\n+  \"out\")\n> balance[balance$desc %in% c(\"Starting Cash\", \"End Cash\"),\n+  \"type\"] <- \"net\" \n \n \n \n \n Next the data will be slightly reworked to specify the coordinates for drawing the waterfall bars. \n \n \n \n \n > balance$end <- cumsum(balance$amount)\n> balance$end <- c(head(balance$end, -1), 0)\n> balance$start <- c(0, head(balance$end, -1))\n> balance <- balance[, c(3, 1, 4, 6, 5, 2)]\n> balance\n id   desc type start end amount\n1 1 Starting Cash net  0 2000 2000\n2 2   Sales in 2000 5400 3400\n3 3  Refunds out 5400 4300 -1100\n4 4  Payouts out 4300 4200 -100\n5 5 Court Losses out 4200 -2400 -6600\n6 6 Court Wins in -2400 1400 3800\n7 7  Contracts in 1400 2800 1400\n8 8  End Cash net 2800  0 2800 \n \n \n \n \n \n Plotting \n Now everything is set to plot the first waterfall chart. geom_rect is used to draw the rectangles using the coordinates calculated in the previous step. \n \n \n \n \n > library(ggplot2) \n \n \n \n \n \n \n \n \n > ggplot(balance, aes(desc, fill = type)) + geom_rect(aes(x = desc,\n+  xmin = id - 0.45, xmax = id + 0.45, ymin = end,\n+  ymax = start)) \n \n \n \n \n \n The fill mapping could use some tweaking (my preference is to have outflows in red, inflows in green, and net position in blue), for that I change the order of the underlying factor levels. \n \n \n \n \n > balance$type <- factor(balance$type, levels = c(\"out\",\n+  \"in\", \"net\")) \n \n \n \n \n Almost ready, one more tweak to the x-axis labels: the helper function below replaces spaces with new lines, making the labels more readable. \n \n \n \n \n > strwr <- function(str) gsub(\" \", \"\\n\", str) \n \n \n \n \n \n \n \n \n > (p1 <- ggplot(balance, aes(fill = type)) + geom_rect(aes(x = desc,\n+  xmin = id - 0.45, xmax = id + 0.45, ymin = end,\n+  ymax = start)) + scale_y_continuous(\"\", formatter = \"comma\") +\n+  scale_x_discrete(\"\", breaks = levels(balance$desc),\n+   labels = strwr(levels(balance$desc))) +\n+  opts(legend.position = \"none\")) \n \n \n \n \n \n Finally, the bar labels are also added (the conditional positioning of them is quite a lengthy process, as you can see). \n \n \n \n \n > p1 + geom_text(subset = .(type == \"in\"), aes(id,\n+  end, label = comma(amount)), vjust = 1, size = 3) +\n+  geom_text(subset = .(type == \"out\"), aes(id,\n+   end, label = comma(amount)), vjust = -0.3,\n+   size = 3) + geom_text(data = subset(balance,\n+  type == \"net\" & id == min(id)), aes(id, end,\n+  colour = type, label = comma(end), vjust = ifelse(end <\n+   start, 1, -0.3)), size = 3.5) + geom_text(data = subset(balance,\n+  type == \"net\" & id == max(id)), aes(id, start,\n+  colour = type, label = comma(start), vjust = ifelse(end <\n+   start, -0.3, 1)), size = 3.5)"], "link": "http://learnr.wordpress.com/2010/05/10/ggplot2-waterfall-charts/", "bloglinks": {}, "links": {"http://had.co.nz/": 1, "http://www.freakalytics.com/": 1, "http://feeds.wordpress.com/": 1}, "blogtitle": "Learning R"}, {"content": ["\u201cHow to change the order of legend labels\u201d is a question that gets asked relatively often on ggplot2 mailing list . A variation of this question is how to change the order of series in stacked bar/lineplots. \n While these two questions seem to be related, in fact they are separate as the legend is controlled by scales, whereas stacking is controlled by the order of values in the data. \n Recently I spent some time getting my head around this, and below is a quick recap. \n  \n \n Changing the Ordering of Legend Labels \n The standard stacked barplot looks like this: \n \n \n \n > library(ggplot2) \n \n \n \n \n \n \n > ggplot(diamonds, aes(clarity, fill = cut)) + geom_bar() \n \n \n \n  \n You notice that in the legend \u201cFair\u201d is at the top and \u201cIdeal\u201d at the bottom. But what if I would like to order the labels in the reverse order, so that \u201cIdeal\u201d would be at the top? \n The order of legend labels can be manipulated by reordering the factor levels of the cut variable mapped to fill aesthetic. \n \n \n \n > levels(diamonds$cut)\n[1] \"Fair\"  \"Good\"  \"Very Good\" \"Premium\"\n[5] \"Ideal\"\n> diamonds$cut <- factor(diamonds$cut, levels = rev(levels(diamonds$cut)))\n> levels(diamonds$cut)\n[1] \"Ideal\"  \"Premium\" \"Very Good\" \"Good\"\n[5] \"Fair\" \n \n \n \n \n \n \n > ggplot(diamonds, aes(clarity, fill = cut)) + geom_bar() \n \n \n \n  \n The legend entries are now in reverse order (and so is the stacking). \n \n Changing Data Stacking Order \n The order aesthetic changes the order in which the areas are stacked on top of each other. \n The following aligns the order of both the labels and the stacking. \n \n \n \n > ggplot(diamonds, aes(clarity, fill = cut, order = -as.numeric(cut))) +\n+  geom_bar() \n \n \n \n  \n Or, alternatively, reordering the factor levels again: \n \n \n \n > diamonds$cut <- factor(diamonds$cut, levels = rev(levels(diamonds$cut)))\n> ggplot(diamonds, aes(clarity, fill = cut, order = -as.numeric(cut))) +\n+  geom_bar()"], "link": "http://learnr.wordpress.com/2010/03/23/ggplot2-changing-the-default-order-of-legend-labels-and-stacking-of-data/", "bloglinks": {}, "links": {"http://feeds.wordpress.com/": 1, "http://groups.google.com/": 1}, "blogtitle": "Learning R"}, {"content": ["Plotting timeseries with dates on x-axis and times on y-axis can be a bit tricky in ggplot2 . However, with a little trick this problem can be easily overcome. \n \n Let\u2019s assume that I wanted to plot when the sun rises in London in 2010. \n sunriset function in maptools package calculates the sunrise times using algorithms provided by the National Oceanic & Atmospheric Administration (NOAA). I need to input the location details in a matrix format and specify for which dates I require the sunrise times. \n \n \n \n \n > library(maptools) \n \n \n \n \n \n \n \n \n > x_seq <- seq(from = as.POSIXct(\"2010-01-01\", tz = \"GMT\"),\n+  length.out = 365, by = \"days\")\n> coord <- matrix(c(-0.13, 51.5), nrow = 1) \n \n \n \n \n \n \n \n \n > sunrise <- sunriset(coord, x_seq, direction = \"sunrise\",\n+  POSIXct.out = TRUE)\n> head(sunrise, 3)\n day_frac    time\n1 0.3376285 2010-01-01 08:06:11\n2 0.3375441 2010-01-02 08:06:03\n3 0.3374209 2010-01-03 08:05:53 \n \n \n \n \n The time variable now includes information about both the date and time of sunrise in class POSIXct . \n I would like to plot date on x-axis and time on y-axis, thus the time element needs to be extracted first. However, as the times must be in POSIXct (only times of class POSIXct are supported in ggplot2 ), a two-step conversion is needed. \n First the time is converted to a character vector, effectively stripping all the date information. The time is then converted back to POSIXct with today\u2019s date \u2013 the date is of no interest to us, only the hours-minutes-seconds are. \n \n \n \n \n > sunrise$hms <- format(sunrise$time, format = \"%H:%M:%S\")\n> sunrise$hms <- as.POSIXct(sunrise$hms, format = \"%H:%M:%S\")\n> head(sunrise, 3)\n day_frac    time     hms\n1 0.3376285 2010-01-01 08:06:11 2010-01-20 08:06:11\n2 0.3375441 2010-01-02 08:06:03 2010-01-20 08:06:03\n3 0.3374209 2010-01-03 08:05:53 2010-01-20 08:05:53 \n \n \n \n \n Now everything is set for plotting. \n \n \n \n \n > library(ggplot2) \n \n \n \n \n \n \n \n \n > ggplot(sunrise, aes(time, hms)) + geom_line() \n \n \n \n \n \n The default x-axis labels could be made somewhat clearer: \n \n \n \n \n > last_plot() + scale_x_datetime(\"\", format = \"%b\") +\n+  ylab(\"\")"], "link": "http://learnr.wordpress.com/2010/02/25/ggplot2-plotting-dates-hours-and-minutes/", "bloglinks": {}, "links": {"http://had.co.nz/": 1, "http://feeds.wordpress.com/": 1, "http://cran.r-project.org/": 1}, "blogtitle": "Learning R"}, {"content": ["A post on FlowingData blog demonstrated how to quickly make a heatmap below using R base graphics. \n This post shows how to achieve a very similar result using ggplot2 . \n  \n  \n \n Data Import \n FlowingData used last season\u2019s NBA basketball statistics provided by databasebasketball.com , and the csv-file with the data can be downloaded directly from its website. \n \n \n \n > nba <- read.csv(\"http://datasets.flowingdata.com/ppg2008.csv\") \n \n \n \n The players are ordered by points scored, and the Name variable converted to a factor that ensures proper sorting of the plot. \n \n \n \n > nba$Name <- with(nba, reorder(Name, PTS)) \n \n \n \n Whilst FlowingData uses heatmap function in the stats -package that requires the plotted values to be in matrix format, ggplot2 operates with dataframes. For ease of processing, the dataframe is converted from wide format to a long format. \n The game statistics have very different ranges, so to make them comparable all the individual statistics are rescaled. \n \n \n \n > library(ggplot2) \n \n \n \n \n \n \n > nba.m <- melt(nba)\n> nba.m <- ddply(nba.m, .(variable), transform,\n+  rescale = rescale(value)) \n \n \n \n \n Plotting \n There is no specific heatmap plotting function in ggplot2 , but combining geom_tile with a smooth gradient fill does the job very well. \n \n \n \n > (p <- ggplot(nba.m, aes(variable, Name)) + geom_tile(aes(fill = rescale),\n+  colour = \"white\") + scale_fill_gradient(low = \"white\",\n+  high = \"steelblue\")) \n \n \n \n  \n A few finishing touches to the formatting, and the heatmap plot is ready for presentation. \n \n \n \n > base_size <- 9\n> p + theme_grey(base_size = base_size) + labs(x = \"\",\n+  y = \"\") + scale_x_discrete(expand = c(0, 0)) +\n+  scale_y_discrete(expand = c(0, 0)) + opts(legend.position = \"none\",\n+  axis.ticks = theme_blank(), axis.text.x = theme_text(size = base_size *\n+   0.8, angle = 330, hjust = 0, colour = \"grey50\")) \n \n \n \n  \n \n Rescaling Update \n In preparing the data for the above plot all the variables were rescaled so that they were between 0 and 1. \n Jim rightly pointed out in the comments (and I did not initally get it) that the heatmap -function uses a different scaling method and therefore the plots are not identical. Below is an updated version of the heatmap which looks much more similar to the original. \n \n \n \n > nba.s <- ddply(nba.m, .(variable), transform,\n+  rescale = scale(value)) \n \n \n \n \n \n \n > last_plot() %+% nba.s"], "link": "http://learnr.wordpress.com/2010/01/26/ggplot2-quick-heatmap-plotting/", "bloglinks": {}, "links": {"http://databasebasketball.com/": 1, "http://had.co.nz/": 1, "http://feeds.wordpress.com/": 1, "http://flowingdata.com/": 1}, "blogtitle": "Learning R"}, {"content": ["Statistical Algorithms blog attempted to recreate a graph depicting the growing colour selection of Crayola crayons in ggplot2 ( original graph below via FlowingData ). \n He also asked the following questions: Is there an easier way to do this? How can I make the axes more like the original? What about the white lines between boxes and the gradual change between years? The sort order is also different. \n I will present my version in this post, trying to address some of these questions. \n \n \n Data Import \n The list of Crayola crayon colours is available on Wikipedia, and also contains one duplicate colour (#FF1DCE) that was excluded to make further processing easier. \n \n \n \n \n > library(XML)\n> library(ggplot2) \n \n \n \n \n \n \n \n \n > theurl <- \"http://en.wikipedia.org/wiki/List_of_Crayola_crayon_colors\"\n> html <- htmlParse(theurl)\n> crayola <- readHTMLTable(html, stringsAsFactors = FALSE)[[2]]\n> crayola <- crayola[, c(\"Hex Code\", \"Issued\", \"Retired\")]\n> names(crayola) <- c(\"colour\", \"issued\", \"retired\")\n> crayola <- crayola[!duplicated(crayola$colour),\n+  ]\n> crayola$retired[crayola$retired == \"\"] <- 2010 \n \n \n \n \n Plotting \n Instead of geom_rect() I will show two options of plotting the same data using geom_bar() and geom_area() to plot the data, and need to ensure that there\u2019s one entry per colour per year it was(is) in the production. \n \n \n \n \n > colours <- ddply(crayola, .(colour), transform,\n+  year = issued:retired) \n \n \n \n \n The plot colours are manually mapped to the original colours using scale_fill_identity() . \n \n \n \n \n > p <- ggplot(colours, aes(year, 1, fill = colour)) +\n+  geom_bar(width = 1, position = \"fill\", binwidth = 1) +\n+  theme_bw() + scale_fill_identity() \n \n \n \n \n \n And now the geom_area() version: \n \n \n \n \n > p1 <- ggplot(colours, aes(year, 1, fill = colour)) +\n+  geom_area(position = \"fill\", colour = \"white\") +\n+  theme_bw() + scale_fill_identity() \n \n \n \n \n \n Final Formatting \n Next, the x-axis labels suggested by ggplot2 will be manualy overridden. Also I use a little trick to make sure that the labels are properly aligned. \n \n \n \n \n > labels <- c(1903, 1949, 1958, 1972, 1990, 1998,\n+  2010)\n> breaks <- labels - 1\n> x <- scale_x_continuous(\"\", breaks = breaks, labels = labels,\n+  expand = c(0, 0))\n> y <- scale_y_continuous(\"\", expand = c(0, 0))\n> ops <- opts(axis.text.y = theme_blank(), axis.ticks = theme_blank()) \n \n \n \n \n \n \n \n \n > p + x + y + ops \n \n \n \n \n \n \n \n \n \n > p1 + x + y + ops \n \n \n \n \n \n The order of colours could be changed by sorting the colours by some common feature, unfortunately I did not find an automated way of doing this. \n Sorting by Colour \n Thanks to Baptiste who showed a way to sort the colours, the final version of the area plot resembles the original even more closely. \n \n \n \n \n > library(colorspace) \n \n \n \n \n \n \n \n \n > sort.colours <- function(col) {\n+  c.rgb = col2rgb(col)\n+  c.RGB = RGB(t(c.rgb) %*% diag(rep(1/255, 3)))\n+  c.HSV = as(c.RGB, \"HSV\")@coords\n+  order(c.HSV[, 1], c.HSV[, 2], c.HSV[, 3])\n+ }\n> colours = ddply(colours, .(year), function(d) d[rev(sort.colours(d$colour)),\n+  ]) \n \n \n \n \n \n \n \n \n > last_plot() %+% colours"], "link": "http://learnr.wordpress.com/2010/01/21/ggplot2-crayola-crayon-colours/", "bloglinks": {}, "links": {"http://had.co.nz/": 1, "http://feeds.wordpress.com/": 1, "http://www.weathersealed.com/": 1, "http://www.statalgo.com/": 1, "http://flowingdata.com/": 1}, "blogtitle": "Learning R"}, {"content": ["Just before Christmas ggplot2 version 0.8.5 was released , closely following the release of version 0.8.4 a week or so earlier. Whilst both versions included included numerous bugfixes (25 in 0.8.4 and 17 in 0.8.5), the latest version also incorporated some new features. \n As ggplot2 is all about graphical display, so I went through the list of new features and below is a visual example of each new feature, plotted most often utilising the code examples included in the respective bugtracker issues. \n \n 1)geom_text gains parse argument which makes it possible to display expressions \n \n \n \n > library(ggplot2) \n \n \n \n \n \n \n > set.seed(1)\n> mydata <- data.frame(x = sample(10), y = sample(10))\n> ggplot(mydata, aes(x, y)) + geom_point() + annotate(\"text\",\n+  x = mydata[6, 1], y = mydata[6, 2], label = \"beta[1] == 1\",\n+  parse = T, vjust = 0, hjust = -0.1) \n \n \n \n  \n 2) all scales now have legend parameter, which defaults to TRUE. Setting to false will prevent that scale from contributing to the legend. \n \n \n \n > ggplot(mydata, aes(x, y, colour = x)) + geom_point(legend = FALSE) +\n+  geom_line() \n \n \n \n  \n In previous version the legend of the above plot looked like this and there was now way to change this. \n \n \n \n > ggplot(mydata, aes(x, y, colour = x)) + geom_point() +\n+  geom_line() \n \n \n \n  \n 3) default axis labels and legend titles are now stored in the options, instead of in each scale. \n This allows to specify them using the opts call. \n \n \n \n > p <- ggplot(mtcars, aes(cyl, mpg, colour = cyl)) +\n+  geom_point()\n> p + opts(labels = c(x = \"Cylinders\", y = \"Miles per gallon\",\n+  colour = \"Colour\")) \n \n \n \n  \n The other options to set labels exist as previously: \n \n \n \n > p + labs(x = \"Cylinders\")\n> p + xlab(\"Cylinders\")\n> p + scale_colour_gradient(name = \"Colour\") \n \n \n \n 4) coord_equal: when ratio = NULL (the default), it will adjust the aspect ratio of the plot, rather than trying to extend the shortest axis. \n \n \n \n > qplot(mpg, wt, data = mtcars) + coord_equal() \n \n \n \n  \n This is what the default looked like in the previous version, and it was impossible to generate the plot above. \n \n \n \n > qplot(mpg, wt, data = mtcars) + coord_equal(ratio = 1) \n \n \n \n  \n 5) x and y positions can be set to Inf or -Inf to refer to the top/right and bottom/left extents of the panel. \n This is useful for annotations, and for geom_rect , geom_vline and geom_hline . \n \n \n \n > ggplot(data.frame(x = 0:1, y = 0:1)) + geom_rect(aes(x = x,\n+  y = y), xmin = 0.1, xmax = 0.2, ymin = -Inf,\n+  ymax = Inf) \n \n \n \n  \n 6)expand_limits(): a new function to make it easy to force the inclusion of any set of values in the limits of any aesthetic. \n \n \n \n > p <- qplot(mpg, wt, data = mtcars) \n \n \n \n  \n \n \n \n > p + expand_limits(x = 0) \n \n \n \n  \n \n \n \n > p + expand_limits(y = c(1, 9)) \n \n \n \n is the equivalent of \n \n \n \n > p + ylim(c(1, 9)) \n \n \n \n  \n \n \n \n > p + expand_limits(x = 0, y = 0) \n \n \n \n  \n It would be good if similar functionality could be extended to xlim , so that the following would work. This way the setting of limits would be encapsulated in one function ( xlim / ylim ). \n \n \n \n > p + xlim(0, Inf)"], "link": "http://learnr.wordpress.com/2010/01/07/new-features-in-ggplot2-version-0-8-5/", "bloglinks": {}, "links": {"http://had.co.nz/": 1, "http://feeds.wordpress.com/": 1, "http://groups.google.com/": 2, "http://github.com/": 1}, "blogtitle": "Learning R"}, {"content": ["Sometimes it is preferable to label data series instead of using a legend. This post demonstrates one way of using labels instead of legend in a ggplot2 plot. \n \n \n \n > library(ggplot2) \n \n \n \n \n \n \n > p <- ggplot(dfm, aes(month, value, group = City,\n  colour = City)) + geom_line(size = 1) +\n  opts(legend.position = \"none\") \n \n \n \n \n \n \n > p + geom_text(data = dfm[dfm$month == \"Dec\",\n  ], aes(label = City), hjust = 0.7, vjust = 1) \n \n \n \n  \n The addition of labels requires manual calculation of the label positions which are then passed on to geom_text() . If one wanted to move the labels around, the code would need manual adjustment \u2013 label positions need to be recalculated.. \n This problem is easily solved with the help of directlabels package by Toby Dylan Hocking that \u201cis an attempt to make direct labeling a reality in everyday statistical practice by making available a body of useful functions that make direct labeling of common plots easy to do with high-level plotting systems such as lattice and ggplot2\u2033. \n \n \n \n > install.packages(\"directlabels\", repos = \"http://r-forge.r-project.org\") \n \n \n \n \n \n \n > library(directlabels) \n \n \n \n The above plot can be reproduced with one line of code. \n \n \n \n > direct.label(p, list(last.points, hjust = 0.7,\n  vjust = 1)) \n \n \n \n In addition to several predefined positioning functions , one can also write their own positioning function. For example, placing the rotated labels at the starting values of each series. \n \n \n \n > angled.firstpoints <- list(\"first.points\",\n  rot = 45, hjust = 0, vjust = -0.7)\n> direct.label(p, angled.firstpoints) \n \n \n \n  \n I agree with the author\u2019s conclusion that the directlabels package simplifies and makes more convenient the labeling of data series in both lattice and ggplot2 . \n Thanks to Baptiste for bringing this package to my attention."], "link": "http://learnr.wordpress.com/2010/01/03/directlabels-adding-direct-labels-to-ggplot2-and-lattice-plots/", "bloglinks": {}, "links": {"http://learnr.wordpress.com/": 2, "http://directlabels.r-project.org/": 3, "http://feeds.wordpress.com/": 1, "http://had.co.nz/": 1}, "blogtitle": "Learning R"}, {"content": ["In 2006 UserR conference Jim Porzak gave a presentation on data profiling with R . He showed how to draw summary panels of the data using a combination of grid and base graphics. \n \n Unfortunately the code has not (yet) been released as a package, so when I recently needed to quickly review several datasets at the beginning of an analysis project I started to look for alternatives. A quick search revealed two options that offer similar functionality: r2lUniv package and describe() function in Hmisc package. \n \n \n r2lUniv \n r2lUniv package performs quick analysis either on a single variable or on a dataframe by computing several statistics (frequency, centrality, dispersion, graph) for each variable and outputs the results in a LaTeX format. The output varies depending on the variable type. \n \n \n \n \n > library(r2lUniv) \n \n \n \n \n One can specify the text to be inserted in front of each section. \n \n \n \n \n > textBefore <- paste(\"\\\\subsection{\", names(mtcars),\n+  \"}\", sep = \"\")\n> rtlu(mtcars, \"fileOut.tex\", textBefore = textBefore) \n \n \n \n \n The function rtluMainFile generates a LaTeX main document design and allows to further customise the report. \n \n \n \n \n > text <- \"\\\\input{fileOut.tex}\"\n> rtluMainFile(\"r2lUniv_report.tex\", text = text) \n \n \n \n \n The resulting tex-file can then be converted into pdf. \n \n \n \n \n > library(tools)\n> texi2dvi(\"r2lUniv_report.tex\", pdf = TRUE, clean = TRUE) \n \n \n \n \n A sample output for the mpg-variable: \n \n The final pdf-output can be seen here: r2lUniv_report.pdf . \n \n Hmisc \n The describe function in Hmisc package determines whether the variable is character, factor, category, binary, discrete numeric, and continuous numeric, and prints a concise statistical summary according to each. The latex report also includes a spike histogram displaying the frequency counts. \n \n \n \n \n > library(Hmisc) \n \n \n \n \n \n \n \n \n > db <- describe(mtcars, size = \"normalsize\") \n \n \n \n \n The easiest and fastest way is to print the results to the console. \n \n \n \n \n > db$mpg\nmpg\n  n missing unique Mean  .05  .10  .25  .50\n  32  0  25 20.09 12.00 14.34 15.43 19.20\n .75  .90  .95\n 22.80 30.09 31.30\n\nlowest : 10.4 13.3 14.3 14.7 15.0\nhighest: 26.0 27.3 30.4 32.4 33.9 \n \n \n \n \n Alternatively, one can convert the describe object into a LaTeX file. \n \n \n \n \n > x <- latex(db, file = \"describe.tex\") \n \n \n \n \n cat is used to generate the tex-report. \n \n \n \n \n > text2 <- \"\\\\documentclass{article}\\n\\\\usepackage{relsize,setspace}\\n\\\\begin{document}\\n\\\\input{describe.tex} \\n\\\\end{document}\"\n> cat(text2, file = \"Hmisc_describe_report.tex\") \n \n \n \n \n \n \n \n \n > library(tools)\n> texi2dvi(\"Hmisc_describe_report.tex\", pdf = TRUE) \n \n \n \n \n A sample output for the mpg-variable: \n \n The final pdf-report can be seen here: Hmisc_describe_report.pdf . \n \n Conclusion \n Both of the functions provide similar snapshots of the data, however I prefer the describe function for its more concise output, and also for the option to print the analysis to the console. Whilst I like the summary plots generated by r2lUniv I find them hard to read in the pdf-report because of the small font-size of the labels."], "link": "http://learnr.wordpress.com/2009/12/17/data-profiling-in-r/", "bloglinks": {}, "links": {"http://learnr.wordpress.com/": 2, "http://feeds.wordpress.com/": 1, "http://www.r-project.org/": 1, "http://cran.r-project.org/": 2}, "blogtitle": "Learning R"}, {"content": ["Hadley Wickham recently shared a nice tip on how to get a faceted scatterplot plot with all points in the background of each plot. \n This technique makes a clever use of setting the faceting variable to NULL so that all points are plotted in light grey in all the facets. \n \n \n \n > library(ggplot2) \n \n \n \n \n \n \n > ggplot(mtcars, aes(cyl, mpg)) + geom_point(data = transform(mtcars,\n  gear = NULL), colour = \"grey80\") + geom_point() +\n  facet_grid(~gear) + theme_bw() \n \n \n \n  \n Update 17 May 2010 \n bch asked in the comments below, how to achieve the same when there are two facets. The method is the same, now one would need to exclude both of the facetting variables from the dataset used to draw the light grey points. \n \n \n \n > ggplot(mtcars, aes(cyl, mpg)) + geom_point(data = mtcars[,\n  !names(mtcars) %in% c(\"am\", \"gear\")],\n  colour = \"grey80\") + geom_point() + facet_grid(am ~\n  gear) + theme_bw()"], "link": "http://learnr.wordpress.com/2009/12/03/ggplot2-overplotting-in-a-faceted-scatterplot/", "bloglinks": {}, "links": {"http://feeds.wordpress.com/": 1, "http://groups.google.com/": 1}, "blogtitle": "Learning R"}]