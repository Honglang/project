[{"blogurl": "http://daily-scala.blogspot.com\n", "blogroll": [], "title": "Daily scala"}, {"content": ["The main design of Scala-IO is around automatic closing of resources each time a resource is accessed in order to ensure that a programmer cannot unintentionally leave resources open in the face of exceptions or other unexpected situations. However, there are cases where the Scala-IO API is desired but the resource management is undesired. The classic case is of reading or writing to System.in and out. Thus Unmanaged resources exist to satisfy this use-case. Since unmanaged resources is a less common use-case there is not a factory object like there is for normal managed Resources. Instead certain objects can be converted to unmanaged resources using the JavaConverters implicit methods as follows:"], "link": "http://daily-scala.blogspot.com/feeds/4128393738525271072/comments/default", "bloglinks": {}, "links": {}, "blogtitle": "Daily scala"}, {"content": ["In order to simplify integration with existing libraries, most commonly Java libraries, Scala-IO provides a JavaConverters object with implicit methods that add as*** methods (asInput, asOutput, asSeekable, etc...) to several types of objects. It is the same pattern as in the scala.collection.JavaConverters object. These methods can be used instead of the Resource.from*** methods to provide a slightly nicer appearing code. There is one warning. When using JavaConverters, instead of Resource.from*** for creating Input/Output/Seekable/etc... objects, the chances of falling into the trap of creating non-reusable resources or causing a resource leak is increased. See: scala-io-core-reusable-resources for more details on this."], "link": "http://daily-scala.blogspot.com/feeds/7414063529560003936/comments/default", "bloglinks": {}, "links": {"http://daily-scala.blogspot.ch/": 1}, "blogtitle": "Daily scala"}, {"content": ["One aspect of resources in Scala-IO that can cause problems is the construction of resource objects. The factory methods that are provided in the Resource object each have a lazy parameter for opening the underlying resource. However a common error developers can make is to pass in the already open resource to the method which has multiple problems. Consider: In the example above the stream is created and opened at the definition of stream (it is a val). This has two effects: the stream is open and if the resource object is not closed you will have a resource leak since the stream is opened the resource can only be used once since it will be closed after each use. The correct way to create the resource would be to change val to def so that the stream is only created on demand and therefore there will be no chance of a resource leak. The following is the correct example: This anti-pattern is also a risk when using the converter methods in the JavaConverters object. (A future post will look into this in more detail.) The following example shows the anti-pattern in effect: The asOutput method can only be applied to an object (at time of this writing) and therefore the resulting object has all of the negative characteristics mentioned above. Therefore it is recommended that asOutput/asInput/etc... only be used on 1 time use resources (like InputStream) within a scope and not passed out to an external method so that it is easy to view the entirety of the operation."], "link": "http://daily-scala.blogspot.com/feeds/5642111879651083598/comments/default", "bloglinks": {}, "links": {}, "blogtitle": "Daily scala"}, {"content": ["The Input and Output objects of Scala-IO assume that the underlying data is composed of bytes. However, another common pattern is to have the underlying data be composed of characters instead of bytes, for example java.io.Reader and java.io.Writer. While it is possible to decompose the output into Bytes and construct an Input object from the decorated object, ReadChars and WriteChars can be used in this situation to reduce the work needed to interact with such resources.  ReadChars and WriteChars are traits that contain the character and string methods of Input and Output. The primary difference is that the Charset is defined by the underlying resource rather than supplied at the method invocation site.  Compare two methods:  Input: def chars(implicit codec: Codec = Codec.default): LongTraversable[Char] ReadChars: def chars: LongTraversable[Char] You will notice that the ReadChars method does not have the codec parameter because there translation is not required, unlike in Input which requires the characters to be created from raw bytes. Not many examples are needed to explain these concepts but here are a few examples on how to create ReadChar and WriteChar objects:"], "link": "http://daily-scala.blogspot.com/feeds/4059910804981273714/comments/default", "bloglinks": {}, "links": {}, "blogtitle": "Daily scala"}, {"content": ["I am getting a lot of emails about Scala-IO and my posts. Just want to let everyone know I am on vacation until September 10th or so. I have some posts in the works but they won't be done here where I have virtually no internet. Back soon."], "link": "http://daily-scala.blogspot.com/feeds/8671059093868149672/comments/default", "bloglinks": {}, "links": {}, "blogtitle": "Daily scala"}, {"content": ["At the same level of abstraction as Input and Output is the fine trait called Seekable. As the name implies it provides random access style methods for interacting with a resource. The example that comes immediately to mind is a random access file. The design of Seekable largely mimics the scala.collection.Seq patch and insert methods. Not much more to say beyond getting into some examples: IMPORTANT: Each time truncate() or patch or insert is called a new connection to the file is opened and closed. The Processor API is to be used to perform multiple operations within one connection."], "link": "http://daily-scala.blogspot.com/feeds/3095384892483885363/comments/default", "bloglinks": {}, "links": {}, "blogtitle": "Daily scala"}, {"content": ["As mentioned in the last post on Output, it is possible to write arbitrary objects to an output object and have it serialized to disk. The way this is handled in Scala-IO is via OutputConverters. If you are familiar with the type-class pattern then this should be very clear to you how this works. For a very quick introduction you can read: http://www.sidewayscoding.com/2011/01/introduction-to-type-classes-in-scala.html . The clue is in the signature of write: def write[T](data: T)(implicit writer: OutputConverter[T]): Unit the last parameter is the object that defines how the object is serialized. The OutputConverter trait essentially converts and object into bytes and has a few built-in implementations in its companion object for objects like Int, Float, Byte, Char, etc...  Since the parameter is implicit the compiler will search for an implementation that satisfies the requirements (that the OutputConverter has the type parameter T). This allows: import scalax.io._ val output:Output = Resource.fromFile(\"scala-io.out\") output write 3 // and output write Seq(1,2,3) // one can be more explicit and declare the OutputConverter output.write(3)(OutputConverter.IntConverter) The last line in the example shows the explicit declaration of the OutputConverter to use when writing the data. This indicates how one can provide their own converter. Since the parameter is implicit there are two ways that custom OutputConverters can be used. defining an implicit object for the object to be written. In this case all the possible ways implicits can be defined can be used. For example as an implicit value or in the companion object of the object to be written (serialized) Explicitly declare the converter to use at the method call site First let's examine the use-case where the object is from a different library and therefore we cannot create a companion object for the object. The second case is where you are implementing the class and therefore can add a companion object: For this next bit to work you need to paste it into a file and run that or use the paste mechanism of the REPL (type :paste into repl and press enter)"], "link": "http://daily-scala.blogspot.com/feeds/2474034726312631871/comments/default", "bloglinks": {}, "links": {"http://www.sidewayscoding.com/": 1}, "blogtitle": "Daily scala"}, {"content": ["The Output object is the primary trait for writing data to a resource. The basic usage is very simple but can get more complex when one wishes to serialize objects. Lets start with the basic usage: A common need is to write several times to a single Output without overwriting the data. To do this one can use the processing API. A future post(s) will look at the processing API in more detail but for now a simple example:"], "link": "http://daily-scala.blogspot.com/feeds/7968388097310139149/comments/default", "bloglinks": {}, "links": {}, "blogtitle": "Daily scala"}, {"content": ["The LongTraversable trait is one of the most important objects in Scala IO. Input provides a uniform way of creating views on the data (as a string or byte array or LongTraversable of something like bytes.) LongTraversable is a scala.collection.Traversable with some extra capabilities. A few of the salient points of LongTraversable are: It is a lazy/non-strict collection similar to Stream. In other words, you can perform operations like map, flatmap, filter, collect, etc... without accessing the resource Methods like slice and drop will (if possible for the resource) skip the dropped bytes without reading them Each usage of the LongTraversable will typically open and close the underlying resource. Has methods that one typically finds in Seq. For example: zip, apply, containsSlice Has methods that take or return Longs instead of Ints like ldrop, lslice, ltake, lsize Has limitFold method that allows fold like behaviour with extra features like skip and early termination Can be converted to an AsyncLongTraversable which has methods that return Futures instead and won't block the program Can be converted to a Process object for advanced data processing pipelines Example usage:  The limitFold method can be quite useful to process only a portion of the file if you don't know ahead of time what the indices of the portion are:"], "link": "http://daily-scala.blogspot.com/feeds/4384437396338880884/comments/default", "bloglinks": {}, "links": {}, "blogtitle": "Daily scala"}, {"content": ["Just a note: all these examples have been tested in REPL so go ahead and fire up the sbt console in the example project and try these out. Resource Resource is the fundamental component of Scala-IO. A Resource is essentially anything that has a simple open/close lifecycle. The Resource trait handles the lifecycle for the developer allowing him to focus on the IO logic. In the typical use-case one of the Resource subclasses will be used. They are more useful in general because they will have one of higher level traits mixed in like Input or Output. The most typical way to create a Resource is with the Resource object which is a factory method for creating Resource objects from various types of Java objects. While Resource is the foundation Trait, Input and Output are the Traits most commonly used, The user-facing traits if you will. Here are a few examples of creating Resources: There are advanced usages of Resource that we will get into in later posts. At the moment I want to focus on Input, Output and Seekable Traits. In later posts we will look at how to integrate with legacy Java APIs and how to access the underlying resource using the loan pattern. Input The Input Trait provides methods for accessing the data of the underlying resource in various different way. As bytes, strings, lines, etc... There are two basic types of methods. Methods that return LongTraversable objects and methods that load the entire Resource into memory. For example: string and byteArray load the entire resource into memory while bytes and chars return a LongTraversable. What is a LongTraversable? That will be the next post :-). Summarized, it is a specialized Lazy/non-strict Traversable."], "link": "http://daily-scala.blogspot.com/feeds/4134985236737627219/comments/default", "bloglinks": {}, "links": {}, "blogtitle": "Daily scala"}, {"content": ["For the next several posts you will need to have Scala-IO installed and probably should have a sbt project as well. There are currently 2 Scala-IO 0.4 releases. Scala-io 0.4-seq - A version of Scala 0.4 without the Akka dependency and therefore no ASync support Scala-io 0.4 - The full version that contains an Akka dependency The Scala 2.10 versions will have no Akka dependency but can optionally use Akka.  So getting started:  Download the example project on the docs website ( http://jesseeichar.github.com/scala-io-doc/latest ): Go to Getting Started and follow instructions for downloading and running the example project. The following goes through the steps for the 0.4.1 instructions.   The last line (Right(770)) is not a command to enter; it is the result of the asynchonous call."], "link": "http://daily-scala.blogspot.com/feeds/6182110459849058961/comments/default", "bloglinks": {}, "links": {"http://jesseeichar.github.com/": 1}, "blogtitle": "Daily scala"}, {"content": ["This is the start of a series of posts on Scala-IO. Scala-IO is as the name implies a library for performing input and output operations with Scala. There are 4 main facets to the library  Basic IO - Reading and writing to some underlying resource. The current implementation is Java based and thus allows reading and writing to resources like java.io.Readers, Writers, Channels, Streams, etc... File API - A library loosely designed after java 7 nio.file API with an additional simple unix like DSL for traversing and searching the filesystem. It is a pluggable architecture which allows plugins for systems like WebDav or Zip filesystems to be addressed in a similar manner as the local filesystem. The included implementation is for the local file system and is implemented on the java.io APIs Asynchronous Access - Throughout the APIs are both synchronous and asynchronous options allowing both models of programming to be easily used.  In the 2.10.x + versions the future implementations are pluggable but require no additional libraries if so that is the desire In 2.9.x versions there are two different dependencies one with asynchronous APIs implemented on Akka and one without any asynchronous APIs Processor API - An API for defining complex IO processes declaratively. This series will look at normally a small and simple IO operation each day (or so) rather than only a few in-depth articles. This is required because of my limited available time. With the introduction done lets look at two small examples:  Read File with Core API (not File API): Same thing but with File API:"], "link": "http://daily-scala.blogspot.com/feeds/4477247816635003894/comments/default", "bloglinks": {}, "links": {}, "blogtitle": "Daily scala"}, {"content": ["A common desire is to have access to the index of an element when using collection methods like foreach, filter, foldLeft/Right, etc... Fortunately there is a simple way.  List( 'a' , 'b' , 'c' , 'd' ).zipWithIndex .  But wait!  Does that not trigger an extra iteration through the collection?. Indeed it does and that is where Views help. List( 'a' , 'b' , 'c' , 'd' ).view.zipWithIndex  When using a view the collection is only traversed when required so there is no performance loss. Here are some examples of zipWithIndex:  scala> \u00a0 val \u00a0list\u00a0=\u00a0List( 'a' , 'b' , 'c' , 'd' ) list:\u00a0List [Char] \u00a0=\u00a0List(a,\u00a0b,\u00a0c,\u00a0d)  /* I\u00a0like\u00a0to\u00a0use\u00a0functions\u00a0constructed\u00a0with\u00a0case\u00a0statements in\u00a0order\u00a0to\u00a0clearly\u00a0label\u00a0the\u00a0index.\u00a0\u00a0The\u00a0alternative\u00a0is\u00a0 to\u00a0use\u00a0x._2\u00a0for\u00a0the\u00a0index\u00a0and\u00a0x._1\u00a0for\u00a0the\u00a0value */ scala> \u00a0list.view.zipWithIndex\u00a0foreach\u00a0{ case \u00a0(value,index)\u00a0=>\u00a0println(value,index)} (a,0) (b,1) (c,2) (d,3)  //\u00a0alternative\u00a0syntax\u00a0without\u00a0case\u00a0statement scala> \u00a0list.view.zipWithIndex\u00a0foreach\u00a0{e\u00a0=>\u00a0println(e._1,e._2)} (a,0) (b,1) (c,2) (d,3)  /* Fold\u00a0left\u00a0and\u00a0right\u00a0functions\u00a0have\u00a02\u00a0parameters\u00a0(accumulator,\u00a0nextValue)\u00a0 using\u00a0a\u00a0case\u00a0statement\u00a0allows\u00a0you\u00a0to\u00a0expand\u00a0that\u00a0but\u00a0watch\u00a0the\u00a0brackets! */ scala> \u00a0(list.view.zipWithIndex\u00a0foldLeft\u00a00)\u00a0{ case \u00a0(acc,(value,index))\u00a0=>\u00a0acc\u00a0+\u00a0value.toInt\u00a0+\u00a0index}\u00a0 res14:\u00a0 Int \u00a0=\u00a0400  //\u00a0alternative\u00a0syntax\u00a0without\u00a0case\u00a0statement scala> \u00a0(list.view.zipWithIndex\u00a0foldLeft\u00a00)\u00a0{(acc,e)\u00a0=>\u00a0acc\u00a0+\u00a0e._1.toInt\u00a0+\u00a0e._2}\u00a0 res23:\u00a0 Int \u00a0=\u00a0400  /* alternative\u00a0foldLeft\u00a0operator.\u00a0\u00a0The\u00a0thing\u00a0I\u00a0like\u00a0about\u00a0this syntax\u00a0is\u00a0that\u00a0it\u00a0has\u00a0the\u00a0initial\u00a0accumulator\u00a0value\u00a0on\u00a0the\u00a0left\u00a0 in\u00a0the\u00a0same\u00a0position\u00a0as\u00a0the\u00a0accumulator\u00a0parameter\u00a0in\u00a0the\u00a0function.  The\u00a0other\u00a0thing\u00a0I\u00a0like\u00a0about\u00a0it\u00a0is\u00a0that\u00a0visually\u00a0you\u00a0can\u00a0see\u00a0that\u00a0it\u00a0starts\u00a0with \"\"\u00a0and\u00a0the\u00a0folds\u00a0left */ scala> \u00a0( \"\" \u00a0/:\u00a0list.view.zipWithIndex)\u00a0{\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0 case \u00a0(acc,\u00a0(value,\u00a0index))\u00a0 if \u00a0index\u00a0%\u00a02\u00a0==\u00a00\u00a0=>\u00a0acc\u00a0+\u00a0value \u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0 case \u00a0(acc,\u00a0_)\u00a0=>\u00a0acc\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0} res15:\u00a0java.lang. String \u00a0=\u00a0ac  /* This\u00a0example\u00a0filters\u00a0based\u00a0on\u00a0the\u00a0index\u00a0then\u00a0uses\u00a0map\u00a0to\u00a0remove\u00a0the\u00a0index force\u00a0simply\u00a0forces\u00a0the\u00a0view\u00a0to\u00a0be\u00a0processed.\u00a0\u00a0(I\u00a0love\u00a0these\u00a0collections!) */ scala> \u00a0list.view.zipWithIndex.filter\u00a0{\u00a0_._2\u00a0%\u00a02\u00a0==\u00a00\u00a0}.map\u00a0{\u00a0_._1}.force res29:\u00a0Seq [Char] \u00a0=\u00a0List(a,\u00a0c)"], "link": "http://daily-scala.blogspot.com/feeds/9110665934253058118/comments/default", "bloglinks": {}, "links": {"http://daily-scala.blogspot.com/": 2}, "blogtitle": "Daily scala"}, {"content": ["A common misunderstanding is that a code block (without parameters) is a function. That is not the case. A code block is a sequence of statements that are executed and result the last statement is returned. That sounds like a Function0, however, if the block is passed to a method/function only the last statement will be returned to the function/method. If that method/function expects a function as the parameter the last statement maybe returned as a function not a value, this means that the block itself is not a function.  scala> \u00a0 var \u00a0count\u00a0=\u00a00\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 count:\u00a0 Int \u00a0=\u00a00  //\u00a0the\u00a0last\u00a0statement\u00a0is\u00a0returned\u00a0as\u00a0a\u00a0function\u00a0so\u00a0count //\u00a0is\u00a0incremented\u00a0only\u00a0one\u00a0during\u00a0the\u00a0creation\u00a0of\u00a0the\u00a0function scala> \u00a0List(1,2,3,4).map{count\u00a0+=\u00a01;_\u00a0+\u00a01} res9:\u00a0List [Int] \u00a0=\u00a0List(2,\u00a03,\u00a04,\u00a05)  scala> \u00a0count res10:\u00a0 Int \u00a0=\u00a01  //\u00a0now\u00a0the\u00a0count\u00a0increment\u00a0is\u00a0within\u00a0the\u00a0function scala> \u00a0List(1,2,3,4).map{i\u00a0=>\u00a0count\u00a0+=\u00a01;i\u00a0+\u00a01} res11:\u00a0List [Int] \u00a0=\u00a0List(2,\u00a03,\u00a04,\u00a05)  scala> \u00a0count res12:\u00a0 Int \u00a0=\u00a05  The previous example demonstrates a Gotcha if I ever saw one. Map expects a function so the block essentially constructs a function. The last statement being the function. The first line count\u00a0+=\u00a01 executed only once because it is part of creating the function not part of the resulting function. This is equivalent to:  scala> \u00a0 val \u00a0x\u00a0=\u00a0{count\u00a0+=\u00a01\u00a0;\u00a0i: Int \u00a0=>\u00a0i\u00a0+1} x:\u00a0( Int )\u00a0=>\u00a0 Int \u00a0=\u00a0<\u00a0function1>  scala> \u00a0List(1,2,3,4).map(x) res15:\u00a0List [Int] \u00a0=\u00a0List(2,\u00a03,\u00a04,\u00a05)  Beginning a block with the parameter list signals that the entire block is a function. Rule of thumb: Functions with placeholder parameters should be a single statement."], "link": "http://daily-scala.blogspot.com/feeds/7155941879432405408/comments/default", "bloglinks": {}, "links": {}, "blogtitle": "Daily scala"}, {"content": ["A second \"gotcha\" that one might get tripped up when dealing with abstract types is the signature of the concrete class contains type information about the abstract type. So if you are not explicit when assigning a variable or defining a function you can get unexpected compiler errors.  scala> \u00a0 trait \u00a0S\u00a0{ \u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0\u00a0 type \u00a0x \u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0\u00a0 def \u00a0get\u00a0:\u00a0x \u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0} defined\u00a0 trait \u00a0S  scala> \u00a0 var \u00a0sample\u00a0=\u00a0 new \u00a0S{\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0\u00a0 type \u00a0x\u00a0=\u00a0 Int \u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0\u00a0 def \u00a0get\u00a0=\u00a03 \u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0} sample:\u00a0java.lang.Object\u00a0 with \u00a0S{ type \u00a0x\u00a0=\u00a0 Int }\u00a0=\u00a0$anon$1 @ 397af435  scala> \u00a0sample\u00a0=\u00a0 new \u00a0S\u00a0{ \u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0\u00a0 type \u00a0x\u00a0=\u00a0 Double \u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0\u00a0 def \u00a0get\u00a0=\u00a03.0 \u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0} <\u00a0console>:7:\u00a0error:\u00a0 type \u00a0mismatch; \u00a0found\u00a0\u00a0\u00a0:\u00a0java.lang.Object\u00a0 with \u00a0S \u00a0required:\u00a0java.lang.Object\u00a0 with \u00a0S{ type \u00a0x\u00a0=\u00a0 Int } \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0sample\u00a0=\u00a0 new \u00a0S\u00a0{  In this example sample uses type inference so the actual type is S with underlying type Int . The consequence is that sample can only be assigned with instances of S with type x = Int . The fix is to explicitly declare the variable type:  scala> \u00a0 var \u00a0sample2\u00a0:\u00a0S\u00a0=\u00a0 new \u00a0S{\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0\u00a0 type \u00a0x\u00a0=\u00a0 Int \u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0\u00a0 def \u00a0get\u00a0=\u00a03 \u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0} sample2:\u00a0S\u00a0=\u00a0$anon$1 @ 31602bbc  scala> \u00a0sample2\u00a0=\u00a0 new \u00a0S\u00a0{ \u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0\u00a0 type \u00a0x\u00a0=\u00a0 Double \u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0\u00a0 def \u00a0get\u00a0=\u00a03.0 \u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0} sample2:\u00a0S\u00a0=\u00a0$anon$1 @ 4de5ed7b  The same thing happens when declaring functions and allows type inference for function definition  scala> \u00a0 class \u00a0Fac\u00a0{ \u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0\u00a0 def \u00a0newS\u00a0=\u00a0 new \u00a0S\u00a0{ \u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0\u00a0\u00a0\u00a0 type \u00a0x\u00a0=\u00a0 Int \u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0\u00a0\u00a0\u00a0 def \u00a0get\u00a0=\u00a03 \u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0\u00a0} \u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0} defined\u00a0 class \u00a0Fac  scala> \u00a0 class \u00a0SubFac\u00a0 extends \u00a0Fac{ \u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0\u00a0 override \u00a0 def \u00a0newS\u00a0=\u00a0 new \u00a0S\u00a0{ \u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0\u00a0\u00a0\u00a0 type \u00a0x\u00a0=\u00a0 Double \u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0\u00a0\u00a0\u00a0 def \u00a0get\u00a0=\u00a03.0 \u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0\u00a0} \u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0} <\u00a0console>:8:\u00a0error:\u00a0 type \u00a0mismatch; \u00a0found\u00a0\u00a0\u00a0:\u00a0java.lang.Object\u00a0 with \u00a0S \u00a0required:\u00a0java.lang.Object\u00a0 with \u00a0S{ type \u00a0x\u00a0=\u00a0 Int } \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 override \u00a0 def \u00a0newS\u00a0=\u00a0 new \u00a0S\u00a0{  The fix for this example is to be explicit in the definition of the function in the superclass"], "link": "http://daily-scala.blogspot.com/feeds/5169502204105236215/comments/default", "bloglinks": {}, "links": {}, "blogtitle": "Daily scala"}, {"content": ["In a previous post about abstract types I showed one of the benefits of using abstract types over parameterized types. Abstract Types vs Parameter . The next several posts will feature potential problems you may encounter when using Abstract Types. I should point out that abstract types are not inherently difficult to understand but they are rather different from anything you will see when you come from the Java world so if you are new to them I would use them with caution at first. In the abstract types example you will notice that the abstract type 'I' in Foreach is not within the trait Source rather it is outside in the Foreach trait. At first one might consider putting the type in Source rather than Foreach. The naive change can get you in trouble (but there is a couple easy fixes)  trait \u00a0Foreach [A] \u00a0{ \u00a0\u00a0 trait \u00a0Source\u00a0{ \u00a0\u00a0\u00a0\u00a0 type \u00a0I\u00a0<:\u00a0java.io.Closeable\u00a0\u00a0 //\u00a0moved\u00a0this\u00a0line\u00a0into\u00a0Source \u00a0\u00a0\u00a0\u00a0 def \u00a0in\u00a0:\u00a0I \u00a0\u00a0\u00a0\u00a0 def \u00a0next(in\u00a0:\u00a0I)\u00a0:\u00a0Option [A] \u00a0\u00a0} \u00a0\u00a0 def \u00a0source\u00a0:\u00a0Source \u00a0\u00a0 \u00a0\u00a0 def \u00a0foreach [U] (f\u00a0:\u00a0A\u00a0=>\u00a0U)\u00a0:\u00a0 Unit \u00a0=\u00a0{ \u00a0\u00a0\u00a0\u00a0 val \u00a0s\u00a0=\u00a0source.in \u00a0\u00a0\u00a0\u00a0 try \u00a0{ \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 def \u00a0processNext\u00a0:\u00a0 Unit \u00a0=\u00a0source.next(s)\u00a0 match \u00a0{ \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 case \u00a0None\u00a0=>\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0() \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 case \u00a0Some(value)\u00a0=>\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0f(value) \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0processNext \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0} \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0processNext \u00a0\u00a0\u00a0\u00a0}\u00a0 finally \u00a0{ \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 //\u00a0correctly\u00a0handle\u00a0exceptions \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0s.close \u00a0\u00a0\u00a0\u00a0} \u00a0\u00a0} }  Compiling the class results in a compilation error: jeichar: tmp$ scalac XX.scala XX.scala:12: error: type mismatch; found : s.type (with underlying type Foreach.this.Source#I) required: _2.I where val _2: Foreach.this.Source  def processNext : Unit = source.next(s) match {           ^ XX.scala:16: error: type mismatch; found : value.type (with underlying type Any) required: A   f(value)    ^ two errors found So what is the problem? The problem is simple but subtle. Notice that source is defined as a def . So calling source 2 times may return 2 different instances of Source. A simple change can fix this. Either change def source : Source to val source : Source. Or change the method foreach to assign the result from source to a val.  trait \u00a0Foreach\u00a0{ \u00a0\u00a0 trait \u00a0Source\u00a0{ \u00a0\u00a0\u00a0\u00a0 type \u00a0I\u00a0<:\u00a0java.io.Closeable\u00a0\u00a0 //\u00a0moved\u00a0this\u00a0line\u00a0into\u00a0Source \u00a0\u00a0\u00a0\u00a0 def \u00a0in\u00a0:\u00a0I \u00a0\u00a0\u00a0\u00a0 def \u00a0next(in\u00a0:\u00a0I)\u00a0:\u00a0Option [Int] \u00a0\u00a0} \u00a0\u00a0 def \u00a0source\u00a0:\u00a0Source \u00a0\u00a0 \u00a0\u00a0 def \u00a0foreach [U] (f\u00a0:\u00a0 Int \u00a0=>\u00a0U)\u00a0:\u00a0 Unit \u00a0=\u00a0{ \u00a0\u00a0\u00a0\u00a0 //\u00a0this\u00a0assignment\u00a0allows\u00a0this\u00a0example\u00a0to\u00a0compile \u00a0\u00a0\u00a0\u00a0 val \u00a0sameSource\u00a0=\u00a0source \u00a0\u00a0\u00a0\u00a0 val \u00a0s\u00a0=\u00a0sameSource.in \u00a0\u00a0\u00a0\u00a0 try \u00a0{ \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 def \u00a0processNext\u00a0:\u00a0 Unit \u00a0=\u00a0sameSource.next(s)\u00a0 match \u00a0{ \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 case \u00a0None\u00a0=>\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0() \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 case \u00a0Some(value)\u00a0=>\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0f(value) \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0processNext \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0} \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0processNext \u00a0\u00a0\u00a0\u00a0}\u00a0 finally \u00a0{ \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 //\u00a0correctly\u00a0handle\u00a0exceptions \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0s.close \u00a0\u00a0\u00a0\u00a0} \u00a0\u00a0} }"], "link": "http://daily-scala.blogspot.com/feeds/7703441129559722054/comments/default", "bloglinks": {}, "links": {"http://daily-scala.blogspot.com/": 2}, "blogtitle": "Daily scala"}, {"content": ["This topic (and the next) are intended to discuss abstract types. A class/trait with an abstract type is quite similar to a class/trait type parameter. For example:   trait C [A] {  def get : A  def doit(a:A):A }  trait C2 {  type A  def get : A  def doit(a:A):A }  Both implementations have similar properties. However they are NOT the same. At first I thought that I could used them inter-changeably. However, consider the following examples:   //compiles def p(c:C [Int] ) = c.doit(c.get)  // doesn't compile def p2(c:C2) = c.doit(c.get)  So why doesn't p2 compile? Because it returns A. From the signature of p2 it is impossible to know what p2 returns. There are several ways to fix this problem. One make the method return Unit:   // compiles because the internals of C2 does not leak out def p(c:C2): Unit = c.doit(c.get)  Another fix would be to change doit to return Unit or an explicit return value like Int   trait C2 {  type A  def get : A  def doit(a:A): Int }  // compiles correctly def p(c:C2) = c.doit(c.get)  A second difference between parameterized types and types with abstract type values is illustrated below:   trait C2 {  type A  def get : A }  scala> var c : C2 = new C2 {  | type A = Int  | def get = 3  | } c: C2 = $anon$1 @ 11a40fff  // what is the type of result if at compile time the // value of c is not known scala> var result = c.get result: C2#A = 3  scala> c = new C2 {    |  type A = String  |  def get = \"hi\"  | } c: C2 = $anon$1 @ 5f154718  // crazy eh :) the variable can be anything but does not // have type Any so you cannot assign arbitrary values scala> result = c.get result: C2#A = hi  scala> result.isInstanceOf [String] res0: Boolean = true  // while the dynamic type of result is a string the // static type is not so you cannot assign a string to result scala> result = \"4\" < console> :8: error: type mismatch; found : java.lang. String ( \"4\" ) required: C2#A   result = \"4\"     ^  The obvious question is what use are abstract types. I don't claim to know them all but the main point is that they do not expose the internal implementation details to the world. The famous cake pattern is one such example usage of abstract types. I read the following as well (wish I could remember where): Abstract types are good when extending and there will be concrete subclasses. Param type good for when a type is useful without extension but can handle several types. A simpler example is examined here. It is loosely based on a real world usecase. The example below is contrived so that it is smaller than the actual usecase, so consider the design and not the fact that the example could be easier done with other examples. In the real scenario this design reduced the lines of duplicated code from around 500 to 10. The example below shows how a Traversable like object can be created from InputStreams and Readers. The important aspect is that the type signature of Foreach does not leak information about the implementation. Users of a Foreach object don't care whether it is backed onto an InputStream or Reader. They just care about the type of object contained. I am leaving this already long post here. The next post will investigate different ways you can get in trouble trying to implement using abstract types.    import java.io.{InputStream, Reader, ByteArrayInputStream, StringReader} import java.net.URL  object Foreach {  def fromStream(s: => InputStream) = new Foreach [Int] {  type I = InputStream  def source = new Source {   def in = s   def next(_in : InputStream) = _in.read match {   case -1 => None   case i => Some(i)  }  } }   def fromReader(s: => Reader) = new Foreach [Char] {  type I = Reader  def source = new Source {   def in = s   def next(_in : Reader) = _in.read match {   case -1 => None   case i => Some(i.toChar)  }  } }    def fromInputAndFunction [A] (s: => InputStream, f: Int => A) = new Foreach [A] {  type I = InputStream  def source = new Source {   def in = s   def next(_in : InputStream) = _in.read match {   case -1 => None   case i => Some(f(i))  }  } }   }  trait Foreach [A] {  type I <: java.io.Closeable  trait Source {  def in : I  def next(in : I) : Option [A]  }  def source : Source   def foreach [U] (f : A => U) : Unit = {  val s = source.in  try {   def processNext : Unit = source.next(s) match {   case None =>    ()   case Some(value) =>    f(value)   processNext  }    processNext  } finally {   // correctly handle exceptions   s.close  } } }  object Test {  def main(args : Array [String] ) = {  val data = \"Hello World\"  val bytes = data.toArray.map { _.toByte }  import Foreach._  fromStream( new ByteArrayInputStream(bytes)).foreach {a => print(a.toChar)}   println  fromReader( new StringReader(data)) foreach print   println   fromInputAndFunction( new ByteArrayInputStream(bytes), i => i.toChar) foreach print   println } }"], "link": "http://daily-scala.blogspot.com/feeds/1410821673305630616/comments/default", "bloglinks": {}, "links": {}, "blogtitle": "Daily scala"}, {"content": ["I picked up this tip from one of Daniel Spiewak's tweets. He tweeted a pro tip that uses flatMap to create a filtered list:  list\u00a0flatMap\u00a0{ \u00a0\u00a0 case \u00a0st:\u00a0 String \u00a0=>\u00a0Some(st) \u00a0\u00a0 case \u00a0_\u00a0=>\u00a0None }  At a glance one might wonder why not simply use list.filter{_.isInstanceOf[String]}. The difference is that the flatMap will return a List[String]. However Scala 2.8 offers the collect method for doing a similar thing.  def \u00a0strings(list:\u00a0List [Any] )\u00a0=\u00a0list\u00a0flatMap\u00a0{ \u00a0\u00a0 case \u00a0st:\u00a0 String \u00a0=>\u00a0Some(st) \u00a0\u00a0 case \u00a0_\u00a0=>\u00a0None }  //\u00a0returned\u00a0list\u00a0is\u00a0a\u00a0List[String] scala> \u00a0strings( \"hi\" \u00a0::\u00a01\u00a0::\u00a0 \"world\" \u00a0::\u00a04\u00a0::\u00a0 Nil ) res11:\u00a0List [String] \u00a0=\u00a0List(hi,\u00a0world)  //\u00a0returned\u00a0list\u00a0is\u00a0a\u00a0List[Any]\u00a0(not\u00a0as\u00a0useful) scala> \u00a0 \"hi\" \u00a0::\u00a01\u00a0::\u00a0 \"world\" \u00a0::\u00a04\u00a0::\u00a0 Nil \u00a0filter\u00a0{_.isInstanceOf [String] } res12:\u00a0List [Any] \u00a0=\u00a0List(hi,\u00a0world)  //\u00a0collect\u00a0returns\u00a0List[String] scala> \u00a0 \"hi\" \u00a0::\u00a01\u00a0::\u00a0 \"world\" \u00a0::\u00a04\u00a0::\u00a0 Nil \u00a0collect\u00a0{ case \u00a0s: String \u00a0=>\u00a0s}\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 res13:\u00a0List [String] \u00a0=\u00a0List(hi,\u00a0world)"], "link": "http://daily-scala.blogspot.com/feeds/5081403443109580065/comments/default", "bloglinks": {}, "links": {}, "blogtitle": "Daily scala"}, {"content": ["This topic is a continuation of the previous implicit parameter topics: Implicit Parameters Companion Object Implicits This topic provides some explanation about how implicit parameters are resulted. There are very strict rules for which implicit value is to be applied to a implicit parameter. A simple way to think about it is that the \"closest\" definition will be used. Local scope, enclosing class, parent class, companion object of the desired type.  class \u00a0X( val \u00a0i: Int ) class \u00a0Y( val \u00a0i: Int )  object \u00a0X\u00a0{ \u00a0\u00a0implicit\u00a0 def \u00a0xx\u00a0=\u00a0 new \u00a0X(1) }  class \u00a0Method\u00a0{ \u00a0\u00a0 def \u00a0x(implicit\u00a0x:X)=println(x.i) \u00a0\u00a0 def \u00a0y(implicit\u00a0y:Y)=println(y.i) }  trait \u00a0M\u00a0{\u00a0 \u00a0\u00a0 self \u00a0:\u00a0Method\u00a0=> \u00a0\u00a0implicit\u00a0 def \u00a0x1\u00a0=\u00a0 new \u00a0X(10) \u00a0\u00a0implicit\u00a0 def \u00a0y1\u00a0=\u00a0 new \u00a0Y(100) \u00a0\u00a0 def \u00a0testy\u00a0=\u00a0y \u00a0\u00a0 def \u00a0testx\u00a0=\u00a0x } trait \u00a0SM\u00a0 extends \u00a0M\u00a0{ \u00a0\u00a0 self \u00a0:\u00a0Method\u00a0=> \u00a0\u00a0implicit\u00a0 def \u00a0x2\u00a0=\u00a0 new \u00a0X(20) \u00a0\u00a0implicit\u00a0 def \u00a0y2\u00a0=\u00a0 new \u00a0Y(200) \u00a0\u00a0 \u00a0\u00a0 def \u00a0testy2\u00a0=\u00a0y\u00a0\u00a0 }  //\u00a0implicit\u00a0resolved\u00a0from\u00a0companion\u00a0object\u00a0of\u00a0X new \u00a0Method().x //\u00a0explicit\u00a0applied\u00a0so\u00a0that\u00a0value\u00a0is\u00a0used new \u00a0Method().x( new \u00a0X(3)) //\u00a0implicit\u00a0resolved\u00a0from\u00a0companion\u00a0object\u00a0of\u00a0X //\u00a0NOT\u00a0from\u00a0M.\u00a0\u00a0This\u00a0is\u00a0because\u00a0the\u00a0call\u00a0site\u00a0of\u00a0x\u00a0 //\u00a0is\u00a0not\u00a0within\u00a0M\u00a0therefore\u00a0does\u00a0not\u00a0use\u00a0the\u00a0implicits\u00a0in\u00a0M //\u00a0for\u00a0resolution. ( new \u00a0Method\u00a0 with \u00a0M).x implicit\u00a0 def \u00a0x\u00a0=\u00a0 new \u00a0X(30) //\u00a0local\u00a0scope\u00a0overrides\u00a0companion\u00a0object\u00a0implicit new \u00a0Method().x //\u00a0explicit\u00a0applied\u00a0so\u00a0that\u00a0value\u00a0is\u00a0used new \u00a0Method().x( new \u00a0X(3)) //\u00a0local\u00a0scope\u00a0overrides\u00a0companion\u00a0object\u00a0implicit ( new \u00a0Method\u00a0 with \u00a0M).x  //\u00a0testy\u00a0is\u00a0defined\u00a0within\u00a0M\u00a0so\u00a0the\u00a0implicits\u00a0within\u00a0M ( new \u00a0Method\u00a0 with \u00a0M).testy //\u00a0testx\u00a0is\u00a0defined\u00a0within\u00a0M\u00a0so\u00a0the\u00a0implicit\u00a0within\u00a0M //\u00a0overrides\u00a0the\u00a0companion\u00a0object\u00a0implicit ( new \u00a0Method\u00a0 with \u00a0M).testx //\u00a0testy\u00a0is\u00a0within\u00a0M\u00a0(not\u00a0SM)\u00a0so\u00a0the\u00a0implicit\u00a0within\u00a0M //\u00a0is\u00a0used ( new \u00a0Method\u00a0 with \u00a0SM).testy //\u00a0testy2\u00a0is\u00a0within\u00a0SM\u00a0so\u00a0the\u00a0implicit\u00a0within\u00a0SM\u00a0 //\u00a0overrides\u00a0the\u00a0implicit\u00a0in\u00a0M\u00a0and\u00a0the\u00a0companion\u00a0object ( new \u00a0Method\u00a0 with \u00a0SM).testy2  Output: 1 3 1 30 3 30 100 10 100 200"], "link": "http://daily-scala.blogspot.com/feeds/1637393118943573005/comments/default", "bloglinks": {}, "links": {"http://daily-scala.blogspot.com/": 2}, "blogtitle": "Daily scala"}, {"content": ["Evidently the topic of implicit parameters has not yet been correctly addressed. There have been several topic that refer to implicit parameters but none that directly discuss them. So before I continue with the topic of implicit parameter resolution I will discuss implicit parameters. First, implicit parameters are not the same as implicit object conversions. Implicit parameters provide a way to allow parameters of a method to be \"found\". This is similar to default parameters at a glance but in fact is a different mechanism for finding the \"default\" value. It differs from implicit object conversion in that it is only a way for parameters for a method to be resolved. Implicit object conversion allows methods to appear to be called on one object when in fact that object is being converted behind the scenes to another type. (more or less) An implicit parameter is a parameter to method or constructor that is marked as implicit. This means that if a parameter value is not supplied then the compiler will search for an \"implicit\" value defined within scope (according to resolution rules.) Implicit parameter resolution rules will be discussed soon. Example:  scala> \u00a0 def \u00a0p(implicit\u00a0i: Int )\u00a0=\u00a0print(i) p:\u00a0(implicit\u00a0i:\u00a0 Int ) Unit  //\u00a0defining\u00a0a\u00a0val/var/def\u00a0as\u00a0implicit\u00a0 //\u00a0means\u00a0that\u00a0it\u00a0will\u00a0be\u00a0considered\u00a0during\u00a0implicit\u00a0resolution scala> \u00a0implicit\u00a0 val \u00a0v=2 v:\u00a0 Int \u00a0=\u00a02  //\u00a0scope\u00a0is\u00a0searched\u00a0for\u00a0a\u00a0implicit\u00a0value\u00a0to\u00a0sue //\u00a0v\u00a0is\u00a0found\u00a0as\u00a0marked\u00a0implicit scala> \u00a0p\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 2  //\u00a0explicit\u00a0declarations\u00a0always\u00a0overrides\u00a0implicit\u00a0values scala> \u00a0p(1) 1  Implicit parameters are very nice for simplifying APIs. For example the collections use implicit parameters to supply CanBuildFrom objects for many of the collection methods. This is because normally the user does not need to be concerned with those parameters. Another example is supplying an encoding to an IO library so the encoding is defined once (perhaps in a package object) and all methods can use the same encoding without having to define it for every method call. One important restriction is that there can only be a single implicit keyword per method. It must be at the start of a parameter list (which also makes all values of that parameter list be implicit). I further understand that only the last parameter list may be implicit. Here are several illegal examples:  //\u00a0implicit\u00a0is\u00a0not\u00a0in\u00a0last\u00a0parameter\u00a0list scala> \u00a0 def \u00a0pp(implicit\u00a0i: Int ,\u00a0a: Int )(b: Int )\u00a0=\u00a0println(a,i)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 <\u00a0console>:1:\u00a0error:\u00a0 '=' \u00a0expected\u00a0but\u00a0 '(' \u00a0found. \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 def \u00a0pp(implicit\u00a0i: Int ,\u00a0a: Int )(b: Int )\u00a0=\u00a0println(a,i)  //\u00a0there\u00a0are\u00a02\u00a0implicit\u00a0parameters scala> \u00a0 def \u00a0pp(implicit\u00a0j: Int ,\u00a0a: Int )(implicit\u00a0i: Int ,b: Int )\u00a0=\u00a0println(a,i) <\u00a0console>:1:\u00a0error:\u00a0 '=' \u00a0expected\u00a0but\u00a0 '(' \u00a0found. \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 def \u00a0pp(implicit\u00a0j: Int ,\u00a0a: Int )(implicit\u00a0i: Int ,b: Int )\u00a0=\u00a0println(a,i)  //\u00a0implicit\u00a0is\u00a0not\u00a0the\u00a0first\u00a0parameter\u00a0of\u00a0the\u00a0parameter\u00a0list scala> \u00a0 def \u00a0pp(a: Int ,\u00a0implicit\u00a0i: Int )\u00a0=\u00a0println(i,j)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 <\u00a0console>:1:\u00a0error:\u00a0identifier\u00a0expected\u00a0but\u00a0 'implicit' \u00a0found. \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 def \u00a0pp(a: Int ,\u00a0implicit\u00a0i: Int )\u00a0=\u00a0println(i,j) \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0^  Here are several legal examples (Updated with useage examples):  scala> \u00a0implicit\u00a0 def \u00a0v\u00a0=\u00a07 v:\u00a0 Int  scala> \u00a0implicit\u00a0 var \u00a0x\u00a0=\u00a010L x:\u00a0 Long  //\u00a0i\u00a0is\u00a0implicit scala> \u00a0 def \u00a0pp(a: Int )(implicit\u00a0i: Int )\u00a0=\u00a0println(a,i) pp:\u00a0(a:\u00a0 Int )(implicit\u00a0i:\u00a0 Int ) Unit  scala> \u00a0pp(3) (3,7)  //\u00a0both\u00a0i\u00a0and\u00a0b\u00a0are\u00a0implicit scala> \u00a0 def \u00a0pp(a: Int )(implicit\u00a0i: Int ,\u00a0b: Long )\u00a0=\u00a0println(a,i,b)\u00a0 pp:\u00a0(a:\u00a0 Int )(implicit\u00a0i:\u00a0 Int ,implicit\u00a0b:\u00a0 Long ) Unit  scala> \u00a0pp(4)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 (4,7,10)  //\u00a0both\u00a0i\u00a0and\u00a0b\u00a0are\u00a0implicit scala> \u00a0 def \u00a0pp(implicit\u00a0i: Int ,\u00a0b: Long )\u00a0=\u00a0println(i,b)\u00a0\u00a0 pp:\u00a0(implicit\u00a0i:\u00a0 Int ,implicit\u00a0b:\u00a0 Long ) Unit  scala> \u00a0pp (7,10)  //\u00a0all\u00a0or\u00a0none\u00a0of\u00a0the\u00a0parameters\u00a0must\u00a0be\u00a0supplied scala> \u00a0pp(2) <\u00a0console>:13:\u00a0error:\u00a0not\u00a0enough\u00a0arguments\u00a0 for \u00a0method\u00a0pp:\u00a0(implicit\u00a0i:\u00a0 Int ,implicit\u00a0b:\u00a0 Long ) Unit . Unspecified\u00a0value\u00a0parameter\u00a0b. \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0pp(2)  //\u00a0This\u00a0is\u00a0syntactically\u00a0legal\u00a0but\u00a0I\u00a0cannot\u00a0seem\u00a0to\u00a0implicitly\u00a0invoke\u00a0this //\u00a0I\u00a0would\u00a0recommend:\u00a0def\u00a0pp(b:Long*)(implicit\u00a0i:Int)\u00a0=\u00a0println(i,b) scala> \u00a0 def \u00a0pp(implicit\u00a0i: Int ,\u00a0b:Long*)\u00a0=\u00a0println(i,b) pp:\u00a0(implicit\u00a0i:\u00a0 Int ,implicit\u00a0b:\u00a0Long*) Unit  scala> \u00a0pp(3,1,2,3) (3,WrappedArray(1,\u00a02,\u00a03))  scala> \u00a0 def \u00a0pp(b:Long*)(implicit\u00a0i: Int )\u00a0=\u00a0println(i,b) pp:\u00a0(b:\u00a0Long*)(implicit\u00a0i:\u00a0 Int ) Unit  scala> \u00a0pp(1,2,3) (7,WrappedArray(1,\u00a02,\u00a03))  A related topic is Companion Object implicits ."], "link": "http://daily-scala.blogspot.com/feeds/1598423674401089187/comments/default", "bloglinks": {}, "links": {"http://daily-scala.blogspot.com/": 1}, "blogtitle": "Daily scala"}, {"content": ["In the Breaks comments there were several questions about the performance of the Scala break command vs the Java break command. So I decided to take a look. The code for the tests is available on GitHub at: Scala Benchmarks . Feel free to play around with it. I personally don't think these tests say anything of particular import because they only test how fast the Java break is vs the Scala break without doing any work in the loop. So I don't expect these number would ever been seen in the real world. However that said if you have a tight loop with minimal processing then a Scala break may not be the correct construct to use. Here is the Java test (labelled JavaSimpleBreak)  int \u00a0i\u00a0=\u00a00; while \u00a0(i\u00a0<\u00a010)\u00a0{ \u00a0\u00a0 if (i==1)\u00a0break; \u00a0\u00a0i\u00a0+=\u00a01; }  Here is the Scala test (labelled ScalaSimpleBreak)  var \u00a0i\u00a0=\u00a00; breakable\u00a0{ \u00a0\u00a0 while \u00a0(i\u00a0<\u00a010)\u00a0{ \u00a0\u00a0\u00a0\u00a0 if (i==1)\u00a0break; \u00a0\u00a0\u00a0\u00a0i\u00a0+=\u00a01; \u00a0\u00a0} }  Out of curiosity I also added a test that created a new Exception each iteration (labelled ScalaException):  var \u00a0i\u00a0=\u00a00; \u00a0\u00a0 while \u00a0(i\u00a0<\u00a010)\u00a0{ \u00a0\u00a0\u00a0\u00a0 if (i==1)\u00a0 throw \u00a0 new \u00a0Exception(); \u00a0\u00a0\u00a0\u00a0i\u00a0+=\u00a01; \u00a0\u00a0}  And also a test that just throws the same ScalaBreak exception each time. This one is weird since Scala Simple Break also throws the same exception but is much much faster so I think there is something about popping the stack in the example compared to the ScalaSimpleBreak test.  var \u00a0i\u00a0=\u00a00; breakable\u00a0{ while \u00a0(i\u00a0<\u00a010)\u00a0{  if (i==1)\u00a0break; i\u00a0+=\u00a01; } }  The results of the tests: First, don't compare the break tests to the Exception tests. They are sufficiently different to not be worth comparing. Second, remember that this is a micro benchmark and has very little relationship to reality. 90000000 iterations. Swapping every 90000000 tests JavaSimpleBreak = 254 (0.0016279129387033098) ScalaSimpleBreak = 2475 (0.015862537493270438) ScalaBreakException = 18806 (0.12052964852462379) ScalaException = 156028 (1.0) 90000000 iterations. Swapping every 500000 tests JavaSimpleBreak = 772 (0.005138547761203965) ScalaSimpleBreak = 2351 (0.015648608531853004) ScalaBreakException = 19346 (0.12876987692778744) ScalaException = 150237 (1.0) 90000000 iterations. Swapping every 500 tests JavaSimpleBreak = 790 (0.005242446563543097) ScalaSimpleBreak = 2247 (0.014911110668710557) ScalaBreakException = 19213 (0.1274976276270298) ScalaException = 150693 (1.0)"], "link": "http://daily-scala.blogspot.com/feeds/8312961293428568620/comments/default", "bloglinks": {}, "links": {"http://daily-scala.blogspot.com/": 1, "http://github.com/": 1}, "blogtitle": "Daily scala"}, {"content": ["When a method requires an implicit there are several ways that the implicit is resolved. One way is to search for an implicit definition in the companion object of the required type. For example: def \u00a0x(implicit\u00a0m:MyClass) parameter m will search local scope, class hierarchy and the MyClass companion object for an implicit val or def. (More on implicit resolution later). To demonstrate the method put the following code block into a file and run the script:  class \u00a0X( val \u00a0i: Int )\u00a0{ \u00a0\u00a0 def \u00a0add(implicit\u00a0x:X)=println(x.i+i) }  object \u00a0X\u00a0{ \u00a0\u00a0implicit\u00a0 def \u00a0xx\u00a0=\u00a0 new \u00a0X(3) }  //\u00a0implicit\u00a0is\u00a0obtained\u00a0from\u00a0companion\u00a0object\u00a0of\u00a0X new \u00a0X(3).add  val \u00a0other\u00a0=\u00a0 new \u00a0{ \u00a0\u00a0 def \u00a0print(implicit\u00a0x:X)=println(x.i) }  //\u00a0implicit\u00a0is\u00a0obtained\u00a0from\u00a0companion\u00a0object\u00a0of\u00a0X other.print implicit\u00a0 def \u00a0x\u00a0=\u00a0 new \u00a0X(32)  //\u00a0implicit\u00a0is\u00a0obtained\u00a0local\u00a0scope other.print  Running: scala impl.scala should produce: 6 3 32"], "link": "http://daily-scala.blogspot.com/feeds/1037858680265945043/comments/default", "bloglinks": {}, "links": {}, "blogtitle": "Daily scala"}, {"content": ["Scala 2.8 added the break control flow option. It is not implemented as a special language feature. Rather it is simply implemented as an object/trait using standard Scala mechanisms. If you are interested in creating a control flow object similar to this look at the Defining Custom Control Structures post. The Break functionality is works basically how you would expect:  //\u00a0Import\u00a0the\u00a0control\u00a0flow\u00a0methodsmethods scala> \u00a0 import \u00a0util.control.Breaks._ import \u00a0util.control.Breaks._  //\u00a0pass\u00a0a\u00a0function\u00a0to\u00a0the\u00a0breakable\u00a0method scala> \u00a0breakable\u00a0{ \u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0 for \u00a0(i\u00a0<-\u00a01\u00a0to\u00a010\u00a0)\u00a0{ \u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0 if (i\u00a0>\u00a05)\u00a0break\u00a0\u00a0 //\u00a0call\u00a0break\u00a0when\u00a0done \u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0println(i) \u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0} \u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0} 1 2 3 4 5  Pretty intuitive but beware, break only breaks out to the first enclosing breakable. Here is an example of the issue:  scala> \u00a0 def \u00a0loop(f\u00a0:\u00a0 Int \u00a0=>\u00a0 Boolean )\u00a0=\u00a0breakable\u00a0{ \u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0 for \u00a0(i\u00a0<-\u00a01\u00a0to\u00a0300)\u00a0 if \u00a0(f(i))\u00a0break\u00a0 else \u00a0println(i) \u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0} loop:\u00a0(f:\u00a0( Int )\u00a0=>\u00a0 Boolean ) Unit  //\u00a0This\u00a0never\u00a0ends\u00a0because\u00a0break\u00a0is\u00a0caught\u00a0by\u00a0breakable\u00a0in\u00a0the\u00a0loop\u00a0method scala> \u00a0breakable\u00a0{ \u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0 while ( true )\u00a0{ \u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0loop{\u00a0i\u00a0=>\u00a0break;\u00a0 true \u00a0} \u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0} \u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0}  Fortunately the implementers provide an elegant way to handle these sorts of cases. The Breaks object extends the Breaks class. By instantiating other instances of Breaks it is possible to control which breaks capture  scala> \u00a0 import \u00a0scala.util.control._ import \u00a0scala.util.control._  scala> \u00a0  scala> \u00a0 def \u00a0loop(f\u00a0:\u00a0 Int \u00a0=>\u00a0 Boolean )\u00a0=\u00a0{ \u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0\u00a0 val \u00a0Inner\u00a0=\u00a0 new \u00a0Breaks \u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0\u00a0Inner.breakable\u00a0{ \u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0\u00a0\u00a0\u00a0 for \u00a0(i\u00a0<-\u00a01\u00a0to\u00a04)\u00a0 if \u00a0(f(i))\u00a0Inner.break\u00a0 else \u00a0println(i) \u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0\u00a0} \u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0} loop:\u00a0(f:\u00a0( Int )\u00a0=>\u00a0 Boolean ) Unit  scala> \u00a0  scala> \u00a0 val \u00a0Outer\u00a0=\u00a0 new \u00a0Breaks Outer:\u00a0scala.util.control.Breaks\u00a0=\u00a0scala.util.control.Breaks @ 1ba4806  scala> \u00a0Outer.breakable\u00a0{ \u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0\u00a0 while ( true )\u00a0{ \u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0\u00a0\u00a0\u00a0loop{\u00a0i\u00a0=>\u00a0 if (i==4)\u00a0Outer.break;\u00a0 false } \u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0\u00a0} \u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0} 1 2 3"], "link": "http://daily-scala.blogspot.com/feeds/4672127917535919875/comments/default", "bloglinks": {}, "links": {"http://daily-scala.blogspot.com/": 1}, "blogtitle": "Daily scala"}, {"content": ["One performance/consistency change that has been make in Scala 2.8 is to make Scala Array always be a Java Array. This has some consequences which we will examine in this post. The biggest one is that Array is not a Scala Collection/Traversable. It is implicitly converted to one but it is not an instance of a Traversable. There are several reasons this was done. Probably the biggest is for performance. Because a Scala array is a Java array there is no overhead when using a Scala array.  Thanks to implicit type conversion all the normal collection methods are useable with an array. Even better, after running a method like map the result will again be a Java array. So the API is much more consistent. An example illustrating that an Array is not a Traversable:  //\u00a0This\u00a0does\u00a0not\u00a0compile\u00a0(which\u00a0is\u00a0good)\u00a0 //\u00a0because\u00a0Traversable[Int]\u00a0can\u00a0never\u00a0be\u00a0an\u00a0array scala> \u00a0 def \u00a0x(t:Traversable [Int] )\u00a0=\u00a0t\u00a0 match \u00a0{ \u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0 case \u00a0x\u00a0:\u00a0Array [Int] \u00a0=>\u00a0 true \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0} <\u00a0console>:13:\u00a0error:\u00a0pattern\u00a0 type \u00a0is\u00a0incompatible\u00a0 with \u00a0expected\u00a0 type ; \u00a0found\u00a0\u00a0\u00a0:\u00a0Array [Int] \u00a0required:\u00a0Traversable [Int] \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 case \u00a0x\u00a0:\u00a0Array [Int] \u00a0=>\u00a0 true \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0^ <\u00a0console>:13:\u00a0error:\u00a0 type \u00a0mismatch; \u00a0found\u00a0\u00a0\u00a0:\u00a0Array [Int] \u00a0required:\u00a0Traversable [Int] \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 case \u00a0x\u00a0:\u00a0Array [Int] \u00a0=>\u00a0 true \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0^  Another example:  scala> \u00a0 def \u00a0x(t:Traversable [Int] )\u00a0=\u00a0t.isInstanceOf [Array [_] ] x:\u00a0(t:\u00a0Traversable [Int] ) Boolean  /*\u00a0this\u00a0evaluates\u00a0to\u00a0false\u00a0because\u00a0Array\u00a0is\u00a0converted \u00a0*\u00a0to\u00a0WrappedArray\u00a0because\u00a0it\u00a0has\u00a0to\u00a0be\u00a0implicitly\u00a0converted \u00a0*\u00a0to\u00a0a\u00a0Traversable.\u00a0\u00a0Since\u00a0Array\u00a0is\u00a0not\u00a0a\u00a0Traversable\u00a0the\u00a0resulting\u00a0 \u00a0*\u00a0object\u00a0is\u00a0not\u00a0an\u00a0Array \u00a0*/ scala> \u00a0x(Array(1,2,3))\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 res24:\u00a0 Boolean \u00a0=\u00a0 false  scala> \u00a0 def \u00a0x(t:Traversable [Int] )\u00a0=\u00a0println(t) x:\u00a0(t:\u00a0Traversable [Int] ) Unit  //\u00a0This\u00a0method\u00a0call\u00a0demonstrates\u00a0the\u00a0previous\u00a0assertion scala> \u00a0x(Array(1,2,3))\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 WrappedArray(1,\u00a02,\u00a03)  So suppose you want to be able to accept and use arrays and Traversables in a method but you want to be able to check that the parameter is an Array. Why not match against WrappedArray. You probably can, but you may get performance improvements in some cases if you don't require wrapping the array.  For a more concrete example of why you may want to do this. In a Input/Output routine I wrote I would write the data one way if the input was an Array: stream.write(array) . But if the input was a traversable then I would have to handle it differently. My particular issue was more complicated than that but that is the basic issue. So the work around is to define a Generic parameter for the method:  scala> \u00a0 def \u00a0x [T\u00a0<%\u00a0Traversable [Int] ](t:T)\u00a0=\u00a0t\u00a0 match \u00a0{\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0 case \u00a0x\u00a0:\u00a0Array [Int] \u00a0=>\u00a0 true \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0} x:\u00a0 [T] (t:\u00a0T)(implicit\u00a0evidence$1:\u00a0(T)\u00a0=>\u00a0Traversable [Int] ) Boolean  scala> \u00a0x(Array(1,2,3))\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 res27:\u00a0 Boolean \u00a0=\u00a0 true"], "link": "http://daily-scala.blogspot.com/feeds/2247063578620063806/comments/default", "bloglinks": {}, "links": {}, "blogtitle": "Daily scala"}, {"content": ["A quick note. ScalaDays Rocks! Wish you were here :) This topic just demonstrates a cute little trick that can occasionally be quite useful:  scala> \u00a0List(1,2,3)\u00a0++\u00a0Some(4) res0:\u00a0List [Int] \u00a0=\u00a0List(1,\u00a02,\u00a03,\u00a04)  scala> \u00a0List(1,2,3)\u00a0++\u00a0None\u00a0\u00a0\u00a0 res1:\u00a0List [Int] \u00a0=\u00a0List(1,\u00a02,\u00a03)  Options are implicitly converted to Iterables, so Options can be appended to collections.  scala> \u00a0 val \u00a0x\u00a0:\u00a0Iterable [Int] \u00a0=\u00a0None\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 x:\u00a0Iterable [Int] \u00a0=\u00a0List()  scala> \u00a0 val \u00a0x\u00a0:\u00a0Iterable [Int] \u00a0=\u00a0Some(4) x:\u00a0Iterable [Int] \u00a0=\u00a0List(4)"], "link": "http://daily-scala.blogspot.com/feeds/4768877119892308699/comments/default", "bloglinks": {}, "links": {}, "blogtitle": "Daily scala"}]