[{"blogurl": "http://timsalimans.com\n", "blogroll": [], "title": "Tim Salimans on Data Analysis"}, {"content": ["Recently I was honored to be named one of Kaggle\u2019s top 10 data scientists. For coverage on the topic see: \n \n http://www.readwriteweb.com/cloud/2012/04/what-you-can-learn-from-kaggle.php \n http://satellite.tmcnet.com/news/2012/04/17/6262977.htm"], "link": "http://timsalimans.com/kaggles-top-10-data-scientists/", "bloglinks": {}, "links": {"http://satellite.tmcnet.com/": 1, "http://www.readwriteweb.com/": 1}, "blogtitle": "Tim Salimans on Data Analysis"}, {"content": ["Some time ago I wrote a post about Gibbs sampling using Matlab . There I showed that the JIT compiler of Matlab can get you very close to the speed of compiled C code if you know what you are doing, but that it is easy to screw up and get a very slow program as a result. More recently, I came across a new scientific programming language called Julia , which seems to be designed specifically with this kind of JIT compilation in mind. So I put Julia to the test, using the slow version of the Gibbs sampler from my last post: \n\n \n  \n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n  function gibbs2(n, thin)\n x_samp = zeros(n,1)\n y_samp = zeros(n,1)\n x=0.0\n y=0.0\n for i=1:n\n  for j=1:thin\n   x=(y^2+4)*randg(3)\n   y=1/(1+x)+randn()/sqrt(2*x+2)\n  end \n  x_samp[i] = x\n  y_samp[i] = y\n end \n return x_samp, y_samp\n end  \n function gibbs2(n, thin)\n x_samp = zeros(n,1)\n y_samp = zeros(n,1)\n x=0.0\n y=0.0\n for i=1:n\n  for j=1:thin\n   x=(y^2+4)*randg(3)\n   y=1/(1+x)+randn()/sqrt(2*x+2)\n  end\n  x_samp[i] = x\n  y_samp[i] = y\n end\n return x_samp, y_samp\nend \n\n\n \n  \n  1\n2\n julia > @ elapsed gibbs2 ( 50000 , 1000 ) \n 7.6084020137786865  \n julia> @elapsed gibbs2(50000,1000)\n7.6084020137786865 \n\n The first thing to notice is that the Julia code looks very similar to the Matlab code from my last post, which is great for people familiar with that language. The second thing is that it is very fast and does not suffer from Matlab\u2019s dumb JIT problems. In fact, this Julia code is even faster than the \u2018fast version\u2019 of the Matlab code from my last post. Way to go Julia!"], "link": "http://timsalimans.com/gibbs-sampling-with-julia/", "bloglinks": {}, "links": {"": 2, "http://www.julialang.org": 1, "http://timsalimans.com/": 1}, "blogtitle": "Tim Salimans on Data Analysis"}, {"content": ["I was very fortunate and pleasantly surprised to receive my school\u2019s \u2018Top Lecturer 2011\u2032 award last week. The award is an encouragement for innovation in education. Among other reasons, I received the award because of how much the students of last year\u2019s \u2018Econometrie 2\u2032 course liked the prediction contest I organized as a class assignment. The competition required the students to model a given \u2018training\u2019 data set in order to predict an unseen \u2018testing\u2019 data set, using the methods that were covered during the course, with the winners of the competition receiving a bonus to their grade. The contest was set up using Kaggle-in-Class : a free service by prediction competition company Kaggle, which makes this process extremely easy. If you are involved in teaching any courses on statistics or data analysis, I would highly recommend having a look at Kaggle-in-Class! \n  \n In addition to Kaggle, I would also like to thank Dennis Fok and Jan Brinkhuis for supporting my development as a teacher, and of course the students who worked hard and made the contest a great experience for everybody!"], "link": "http://timsalimans.com/kaggleinclass/", "bloglinks": {}, "links": {"http://inclass.kaggle.com/": 1, "http://timsalimans.com/": 1}, "blogtitle": "Tim Salimans on Data Analysis"}, {"content": ["Darren Wilkinson has an interesting blog post , comparing execution times of a Gibbs sampler implemented in various different programming languages. His sampler generates draws from the following joint distribution \n \n by drawing iteratively from the full conditional distributions \n \n and \n . \n Darren presents different implementations of this sampler in R, Python, C, Java, Scala, and Groovy, and then compares their running times. You will have to take a look at Darren\u2019s blog post for the complete results, but one thing they show is that popular interpreted languages such as R and Python are many times slower than compiled C code. \n With this in mind I decided to give his sampler a try myself, using one of my\u00a0favorite\u00a0languages for quick prototyping: Matlab. Here\u2019s the code and corresponding running time: \n \n function [x_samp,y_samp] = gibbs(n,thin)\n\nx_samp = zeros(n,1);\ny_samp = zeros(n,1);\n\ny=0;\n for i=1:n\n gammarands=randg(3,thin,1);\n normrands=randn(thin,1);\n\n  for j=1:thin\n  x=(y^2+4)*gammarands(j);\n  y=1/(1+x)+normrands(j)/sqrt(2*x+2);\n  end \n\n x_samp(i) = x;\n y_samp(i) = y;\n\n end \n end \n \n \n tic\ngibbs(5e4,1e3);\ntoc \n Elapsed time is 10.027671 seconds. \n \n Although Matlab is also an interpreted language, this running time of 10 seconds is remarkably close to the ~8 seconds Darren reports for compiled C code (using a PC very similar to mine). The reason that the code above is so fast is that Matlab internally compiles the inner loop of the \u2018gibbs\u2019 function; a trick called \u2018Just In Time\u2019 compilation. For obtaining the random numbers used by the function, Matlab uses fast built-in code (the \u2018randn\u2019 and \u2018randg\u2019 functions) which are only called once every 1000 iterations of the inner loop (1000 being the value of the \u2018thin\u2019 parameter). Despite its similar speed, coding and running the Matlab example above is much easier than coding, compiling, and running the corresponding C code. \n The Matlab JIT compiler is powerful, but not very smart: it can only compile very simple operations like those found in the inner loop of the code above. This means that we have to be very careful with the operations we perform in the inner loop of a function. The example below shows what happens when we move the random number generation (\u2018randn\u2019 and \u2018randg\u2019) to the inner loop: \n \n function [x_samp,y_samp] = gibbs2(n,thin)\n\nx_samp = zeros(n,1);\ny_samp = zeros(n,1);\n\ny=0;\n for i=1:n\n\n  for j=1:thin\n  x=(y^2+4)*randg(3,1,1);\n  y=1/(1+x)+randn/sqrt(2*x+2);\n  end \n\n x_samp(i) = x;\n y_samp(i) = y;\n end \n end \n \n tic\ngibbs2(5e4,1e3);\ntoc \n Elapsed time is 218.589886 seconds. \n \n The new code takes 20 times as long! The problem with the new code is that Matlab does not know what to do with the \u2018randn\u2019 and \u2018randg\u2019 functions until it executes them, and is therefore no longer able to compile the inner loop of the algorithm. \n To summarize: compiled code can be much faster than interpreted code for number crunching, but if we are smart and use JIT compilation well, we can get remarkably close! \n Note that many other languages besides Matlab also support some form of JIT compilation: Darren Wilkinson\u2019s post has a nice example of speeding things up by JIT compiling Python code."], "link": "http://timsalimans.com/the-power-of-jit-compilation/", "bloglinks": {}, "links": {"http://darrenjw.wordpress.com/": 1}, "blogtitle": "Tim Salimans on Data Analysis"}, {"content": ["The\u00a0 Deloitte/FIDE Chess Rating Challenge \u00a0has been getting quite some attention in the media. Competition organizer Jeff Sonas has a nice article on Chessbase.com, which does a great job of explaining the competition. The Australian TV channel ABC broadcast a great show on Kaggle, the company that hosts these prediction competitions: \n  \n If you watch very very carefully you might even catch a glimpse of me!"], "link": "http://timsalimans.com/prediction-contests-in-the-media/", "bloglinks": {}, "links": {"http://wp.me/": 1, "http://www.chessbase.com/": 1, "http://www.net.au/": 1}, "blogtitle": "Tim Salimans on Data Analysis"}, {"content": ["I have uploaded the code for my entry in the \u201cDon\u2019t Overfit!\u201d prediction competition. For this competition I used Bayesian inference, implemented using Gibbs sampling. For details see my earlier post . Click here for\u00a0 the code."], "link": "http://timsalimans.com/code-for-dont-overfit-competition/", "bloglinks": {}, "links": {"http://wp.me/": 2, "http://www.kaggle.com/": 1}, "blogtitle": "Tim Salimans on Data Analysis"}, {"content": ["Between February 28, 2011 and May 15, 2011, Kaggle hosted a prediction competition entitled \u201cDon\u2019t Overfit!\u201d. The goal of this competition was to develop a model that would predict well in a setting where you have little data and many explanatory variables. I was lucky enough to end up winning one of the two parts of the competition, as well as being the overall winner. Below you can find a cross-post of the description of my winning entry: \n The data set for this competition was an artificial data set created by competition organizer Phil Brierley, consisting of 250 observations of a binary \u201ctarget\u201d variable and 200 different \u201cexplanatory variables\u201d. The goal was to model the relationship between the explanatory variables and the targets in order to predict another 19750 holdout target variables. To do this well, one has to avoid the trap of \u201coverfitting\u201d, i.e. creating a model with a good in-sample fit but with poor predictive performance. The question \u201chow do we prevent overfitting?\u201d has been asked again and again, but in my opinion the answer has been known since Laplace: use Bayesian analysis with a sensible prior. \n A Bayesian analysis of any problem consists of two steps: \n 1. Formulate your prior guess about how the data was generated in terms of a probability distribution. In this case let\u2019s call that distribution p(T), with T the full 20,000\u00d71 vector of targets. \n 2.Condition on the observed data to make predictions, i.e. construct the posterior distribution p(T_predict | T_observed) where T_observed is now the 250\u00d71 vector of observed targets. The predictions can then be obtained by minimizing the expected loss under this posterior distribution. I did not have time to properly look into the AUC measure used to judge accuracy in this competition, but I guessed it would be (near) optimal to just use the conditional expectations E(T_predict | T_observed) as my predictions. Taking the expectation over the posterior distribution implies averaging over all models and variable selections that are plausible given the data T_observed. Because of this averaging, Bayes is inherently less prone to overfitting than estimation methods that are optimization-based. \n Different people may have different ideas on what the appropriate prior distribution p(T) should be, but the nice thing about Bayes is that, conditional on our choice for p(T), it automatically gives us the predictions with the lowest expected loss! (the statistician Dennis Lindley famously called this \u201cturning the Bayesian crank\u201d) For this competition this really meant the following: the only thing that the competitors would have needed to discuss is how Phil generated the data. Given our guess about Phil\u2019s data generating process, Bayes then gives us the ideal predictions. (in expectation\u2026 this contest was quite random due to the small sample size) \n I started this contest with very little time left, but fortunately the other participants had already left me lots of clues in the forum. In particular, a quick read revealed the following: \n -\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 The \u201cequation\u201d used to generate the data seemed to be linear \n -\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 The coefficient of the explanatory variables all seemed to be of the same sign \n -\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 According to Phil the \u201cequation\u201d did not have any noise in it \n Based on these clues and some experimentation, I guessed that the data was generated as follows: \n 1. Sample the 200 explanatory variables \u2018X\u2019 uniformly on [0,1] \n 2. With probability 0.5 select each different X variable for use in the \u201cequation\u201d \n 3. For each included variable uniformly sample a coefficient A \n 4. Define Y = A_1*X_1 + A_2*X_2 etc \n 5. Define Z = Y \u2013 mean(Y) \n 6. Set T_i = 1 if Z_i < 0 and set T_i = 0 otherwise \n 8. Round all X variables to 3 decimal places \n The above defines the prior distribution p(T) to be used in the Bayesian analysis. The posterior distribution can then be approximated quite straightforwardly using Gibbs sampling. This Gibbs sampler will then average over all probable coefficients A and all probable X (since we only observed the rounded X\u2019s). My implementation of this turned out to be good enough for me to become the overall winner of the competition. (for the complete results, see here ) \n I had fun with this competition and I would like to thank Phil Brierley for organizing it. If this post has coincidentally managed to convert any of you to the Bayesian religion , I strongly recommend reading Jaynes\u2019s \u201cProbability Theory: The Logic of Science\u201d, of which the first few chapters can be read online here .\u00a0(that\u2019s how I first learned Bayesian analysis)"], "link": "http://timsalimans.com/winning-the-dont-overfit-competition/", "bloglinks": {}, "links": {"http://bayes.wustl.edu/": 1, "http://www.kaggle.com/": 3, "http://kaggle.com": 1}, "blogtitle": "Tim Salimans on Data Analysis"}, {"content": ["This year, from February 7 to May 4, a prediction contest was held at Kaggle.com/c/ChessRatings2 where I ended up taking first place. The goal of the contest was to build a model to forecast the results of future chess matches based on the results of past matches. This post contains a description of my approach. The corresponding MATLAB code can be found here . For a non-technical account of my experiences in the competition, see my earlier post . \n The base model \n The basic model underlying my approach was inspired strongly by the TrueSkill model , as well as by the winner and runner-up of an earlier chess rating contest on Kaggle. The final model was programmed in Matlab, but some of the early experimentation was done using the Infer.NET package, which is definitely worth having a look at. Warning: The discussion in this section is somewhat technical. \n The basic statistical model assumed for the result of a match between a white player A and a black player B is the familiar ordered probit model: \n , \n if > 1 : A wins \n if -1 < < 1 : A and B draw \n if < -1 : B wins \n Here can be seen as the _performance difference_ between A and B in this match, and as the skills of player A and B, as the advantage of playing white, and as a random error term. \n Given a set of match results, we will infer the skills of all players by means of factorized approximate Bayesian inference. and are estimated using approximate maximum likelihood . \n We specify an independent normal prior for each player\u2019s skill , having mean and a variance of 1 (determined by cross validation). The means can be initialized to 0 and will be set to a weighted average of the posterior means of the skills of each players\u2019 opponents at each iteration. The effect of this is to shrink the skills of the players to those of their opponents, as was first done by Yannis Sismanis . \n Given a set of match results , the skills have the following posterior density \n \n where is the standard normal distribution function, is the likelihood term due to the match result , and and identify the white and black player in match . This posterior distribution is of a very high dimension and is not of any standard form, which makes it intractable for exact inference. Approximate Bayesian inference can solve this problem by approximating the above density by a product of univariate normal densities. \n \n There exist various ways of obtaining the mean and variance terms ( , , , ) in this pseudo-posterior. The two methods I tried were expectation propagation , as is used in the TrueSkill model and Laplace approximation, as used here in a similar context. For the current model and data set the results for both methods were practically the same. The advantage of the Laplace approximation is that it is easier to apply when we change the ordered probit specification to something else like a (ordered or multinomial) logit model. However, since the ordered probit specification provided the best fit, my final submission was made using this specification in combination with expectation propagation. Both methods can only be applied directly when we know which of the two players was playing white. This wasn\u2019t the case for part of the data. My solution to this problem was to calculate the likelihood terms for both the case that the first player is white as well as the case that the second player is white, after which I weight the likelihood terms of both cases by their respective posterior probabilities. This is the natural thing to do when using the Laplace approximation, but it also works well with expectation propagation. \n In estimating the skills of the players we would like to assign more importance to matches that have occurred recently than to matches that were played long ago. The main innovation in my approach is to do this by replacing the pseudo posterior above with a weighted version: \n \n for weights and between zero and one. Since the normal distribution is a member of the exponential family this does not change the functional form of the posterior. Because of this, the weights can be incorporated quite naturally into the expectation propagation algorithm. An advantage of using this weighting scheme in combination with factorized approximate inference is that each match may now have a different weight for each of the two players. This is not possible using more conventional weighting methods like the one used to win the first Kaggle chess competition. \n The use of a weighted likelihood in a Bayesian framework is an ad hoc solution, but can be viewed as a way of performing approximate inference in a model where the skills vary over time according to some stochastic process. An alternative solution would be to assume that this stochastic process is a (possibly mean-reverting) random walk, in which case we could use a forward-backward algorithm similar to the Kalman filter. However, for this particular problem the weighting approach performed slightly better. \n After trying multiple options, the weight function chosen was , with the number of matches played by this player between the current month and the end of the sample, the number of months in the same period, and an indicator variable equal to one if match is from the tertiary data set, which was of lower quality. The coefficients in this function were determined by cross-validation. There were other weighting schemes that showed some promise, such as overweighting those matches with players close in skill level to player B, when estimating the skill of player A for predicting his/her result against B. Alternatively, we could overweight those matches containing players that regularly played against B, as we can be more certain about their strength in relation to B than for players that have never played against this player. Due to time constraints I was unable to explore these possibilities further. The combination of approximate inference with likelihood weighting may be an interesting topic for future research. \n Post-processing \n The predictions of the base model scored very well on the leaderboard of the competition, but they were not yet good enough to put me in first place. It was at this time that I realized that the match schedule itself contained useful information for predicting the results, something that had already been noticed by some of the other competitors. In chess, most tournaments are played according to the Swiss system , in which in each round players are paired with other players that have achieved a comparable performance in earlier rounds. This means that if in a given tournament player A has encountered better opponents than player B, this most likely means that player A has won a larger percentage of his/her matches in that tournament. \n In order to incorporate the information present in the match schedule, I generated out-of-sample predictions for the last 1.5 years of data using a rolling 3-month prediction window. (i.e. predicting months 127-129 using months 1-126, predicting months 130-132 using months 1-129 etc.) I then performed two post-processing steps using these predictions and the realized match outcomes, the first using standard logistic regression and the second using a locally weighted variant of logistic regression. These post-processing steps used a large number of different variables as can be seen in the code below, but the most important variables were: \n \n \n the predictions of the base model \n the posterior means of the skills of A and B \n the number of matches played by these players \n the posterior means of the skills of the opponents encountered by A and B \n the variation in the quality of the opponents \n the average predicted win percentage over all matches in the same month for these players \n the predictions of a random forest using these variables \n \n \n By comparing the quality of the opponents of A and B in a given tournament we may predict the result of the match between A and B. However, the data only indicated the month in which each match was played and not the tournament, and some players appear to have played in multiple tournaments in the same month. What finally pulled me ahead of the competition may have been the addition of a variable that weighs the skills of the opponents of B by their rooted pagerank to A on the match graph. The idea behind this was that if a player C, who played against B, is close to A on the match graph, the match between B and C most likely occurred in the same tournament as the match between A and B. \n In order to make the locally weighted logistic regression computationally feasible, the post-processing procedure first allocates the matches in the test set into a small number of cluster points for which the logistic regression is performed. For the final prediction we can then use local interpolation between the parameter estimates at the cluster centers using Gaussian processes . Using this approach the post-processing was sufficiently fast to allow me to quickly try many different settings and variables. \n Conclusions \n I would like to thank both the organizers and the competitors for a great competition. Much of the contest came down to how to use the information in the match schedule. Although interesting in its own right, this was less than ideal for the original goal of finding a good rating system. Despite of this I hope that the competition, and my contribution to it, was useful and that it will help to advance the science of rating systems."], "link": "http://timsalimans.com/how-i-won-the-deloittefide-chess-rating-challenge/", "bloglinks": {}, "links": {"http://blog.kaggle.com/": 1, "http://bayes.wustl.edu/": 1, "http://www.ucsd.edu/": 1, "http://timsalimans.com/": 1, "http://www.kaggle.com/blog": 2, "http://citeseerx.psu.edu/": 2, "http://www.gaussianprocess.org/": 1, "http://www.mathworks.com/": 1, "http://en.wikipedia.org/": 4, "http://videolectures.net/": 1, "http://research.microsoft.com/": 2, "http://wp.me/": 1, "http://www.kaggle.com/": 1, "http://kaggle.com/": 1}, "blogtitle": "Tim Salimans on Data Analysis"}, {"content": ["The following is a cross-post of my contribution to the Kaggle blog , made after winning the\u00a0 Deloitte/FIDE Chess Rating Challenge : a contest for developing a new predictive system for ranking chess players, sponsored by Deloitte Analytics Australia and the world chess federation FIDE. \n My name is Tim Salimans and I am a PhD candidate in Econometrics at Erasmus University Rotterdam. For my job I constantly work with data, models, and algorithms, and the Kaggle competitions seemed like a fun way of using these skills in a competitive and social environment. The Deloitte/FIDE Chess Rating Challenge was the first Kaggle contest I entered and I was very fortunate to end up taking first place. During the same period I also used Kaggle-in-class to host a prediction contest for an undergraduate course in Econometrics for which I was the teaching assistant. Both proved to be a lot of fun. \n Chess rating systems \n The first thing to do when tackling a new problem is to look up what other people have done before you. Since Kaggle had already organized an earlier chess rating competition, the blog posts of the winners were a logical place to start. After reading those posts and some of the academic literature, I found that chess rating systems usually work by assuming that each player\u2019s characteristics can be described by a single rating number. The predicted result for a match between two players is then taken to be some function of the difference between their ratings. Yannis Sismanis, the winner of the first competition, used a logistic curve for this purpose and estimated the rating numbers by minimizing a regularized version of the model fit. Jeremy Howard, the runner-up, instead used the TrueSkill model, which uses a Gaussian cumulative density function and estimates the ratings using approximate Bayesian inference. \n I decided to start out with the TrueSkill model and to extend it by shrinking each player\u2019s rating to that of their recent opponents, similar to what Yannis Sismanis had done in the first competition. In addition, I introduced weights into the algorithm which allowed me to put most emphasis on the matches that were played most recently. After some initial experimentation using the excellent\u00a0 Infer.NET \u00a0package, I programmed everything in Matlab. \n Using the match schedule \n The predictions of my base model scored very well on the leaderboard of the competition, but they were not yet good enough to put me in first place. It was at this time that I realized that the match schedule itself contained useful information for predicting the results, something that had already been noticed by some of the other competitors. In chess, most tournaments are organized using to the Swiss system, in which in each round players are paired with other players that have achieved a comparable performance in earlier rounds. If in a Swiss system tournament player A has encountered better opponents than player B, this most likely means that player A has won a larger percentage of his/her matches in that tournament. \n In order to incorporate the information present in the match schedule, I generated out-of-sample predictions for the last 1.5 years of the data using a rolling 3-month prediction window. I then performed two post-processing steps using these predictions and the realized match outcomes. The first step used standard logistic regression and the second step used a locally weighted variant of logistic regression. The most important variables used in the post-processing procedure were: \n \n \u00a0the predictions of the base model \n \u00a0the ratings of the players \n \u00a0the number of matches played by each player \n \u00a0the ratings of the opponents encountered by each player \n \u00a0the variation in the quality of the opponents encountered \n \u00a0the average predicted win percentage over all matches in the same month for each player \n \u00a0the predictions of a random forest using these variables \n \n This post-processing dramatically improved my score and put me well ahead of the competition for some time. Later, other competitors made similar improvements and the final weeks of the competition were very exciting. After a long weekend away towards the end of the competition I came back to find that I had been surpassed on the leaderboard by team PlanetThanet. By tweaking my approach I was able to crawl back up during the next few days, after which I had to leave for a conference in the USA. Upon arrival I learned that I was again surpassed, now by Shang Tsung. Only by making my last submissions from my hotel room in St. Louis was I finally able to secure first place. \n Conclusions \n Much of the contest came down to how to use the information in the match schedule. Although interesting in its own right, this was less than ideal for the original goal of finding a good rating system. To my relief, the follow-up data set that Jeff Sonas made available showed that my model also makes good predictions without using this information. Finally, I would like to thank both the organizers and the competitors for a great competition!"], "link": "http://timsalimans.com/winning-the-deloittefide-chess-comp/", "bloglinks": {}, "links": {"http://blog.kaggle.com/": 1, "http://research.microsoft.com/": 1, "http://www.kaggle.com/": 1}, "blogtitle": "Tim Salimans on Data Analysis"}]